module Defaults

importall ..Builder
import Base.promote_rule
export @u_str

# Default dimensions and their abbreviations.
# The dimension symbols are generated by tab completion: \mbfL is 𝐋, etc.
# This is kind of a compromise on polluting the namespace.
@dimension 𝐋 "𝐋" Length
@dimension 𝐌 "𝐌" Mass
@dimension 𝐓 "𝐓" Time
@dimension 𝐈 "𝐈" Current
@dimension 𝚯 "𝚯" Temperature    # This one is \mbfTheta
@dimension 𝐉 "𝐉" Luminosity
@dimension 𝐍 "𝐍" Amount

# Define derived dimensions.
@derived_dimension Area             𝐋^2
@derived_dimension Volume           𝐋^3
@derived_dimension Frequency        inv(𝐓)
@derived_dimension Force            𝐌*𝐋/𝐓^2
@derived_dimension Pressure         𝐌*𝐋^-1*𝐓^-2
@derived_dimension Energy           𝐌*𝐋^2/𝐓^2
@derived_dimension Momentum         𝐌*𝐋/𝐓
@derived_dimension Power            𝐋^2*𝐌*𝐓^-3
@derived_dimension Charge           𝐈*𝐓
@derived_dimension Voltage          𝐈^-1*𝐋^2*𝐌*𝐓^-3
@derived_dimension Resistance       𝐈^-2*𝐋^2*𝐌*𝐓^-3
@derived_dimension Capacitance      𝐈^2*𝐋^-2*𝐌^-1*𝐓^4
@derived_dimension Inductance       𝐈^-2*𝐋^2*𝐌*𝐓^-2
@derived_dimension MagneticFlux     𝐈^-1*𝐋^2*𝐌*𝐓^-2
@derived_dimension HField           𝐈/𝐋
@derived_dimension BField           𝐈^-1*𝐌*𝐓^-2

# Define base units. This is not to imply g is the base SI unit instead of kg.
# See the documentation for further details.
# #key:   Symbol  Display  Name      Dimension   Prefixes?
@refunit  m       "m"      Meter     𝐋           true
@refunit  s       "s"      Second    𝐓           true
@refunit  A       "A"      Ampere    𝐈           true
@refunit  K       "K"      Kelvin    𝚯           true
@refunit  cd      "cd"     Candela   𝐉           true
@refunit  g       "g"      Gram      𝐌           true
@refunit  mol     "mol"    Mole      𝐍           true

# Specify preferred unit for promotion.
# This is separate from the @refunit macro for flexibility; consider that
# the SI unit of mass is not g but instead kg, and yet some people use cgs units.
# This macro should only be used with units having "pure" dimensions like 𝐋, 𝐓, 𝐈, etc.
@preferunit m
@preferunit s
@preferunit A
@preferunit K
@preferunit cd
@preferunit kg
@preferunit mol

## Length
#key: Symbol Display    Name        Equivalent to           10^n prefixes?
@unit mi     "mi"       Mile        (201168//125)*m         false
@unit yd     "yd"       Yard        (9144//10000)*m         false
@unit ft     "ft"       Foot        (3048//10000)*m         false
@unit inch   "in"       Inch        (254//10000)*m          false

# Area
@unit ac     "ac"       Acre        (316160658//78125)*m^2  false
@unit a      "a"        Are         100m^2                  false

# Volume
@unit L      "L"        Liter       0.001m^3                true
# l is also an acceptable symbol for liters
for p in (:y, :z, :a, :f, :p, :n, :μ, :µ, :m, :c, :d,
    Symbol(""), :da, :h, :k, :M, :G, :T, :P, :E, :Z, :Y)
    @eval const $(Symbol(p, :l)) = $(Symbol(p, :L))
end

# The hectare is used more frequently than any other power-of-ten of an are.
const ha = Units{(Unit{:Are}(2,1//1),), typeof(𝐋)}()

# Time
@unit minute "min"      Minute      60s                     false
@unit hr     "hr"       Hour        3600s                   false
@unit d      "dy"       Day         86400s                  false
@unit wk     "wk"       Week        604800s                 false

# Angles and solid angles
@unit sr      "sr"      Steradian   1                       true
@unit rad     "rad"     Radian      1                       true
@unit °       "°"       Degree      pi/180                  false
# For numerical accuracy, specific to the degree
import Base: sin, cos, tan, sec, csc, cot
import Base: sind, cosd, tand, secd, cscd, cotd
for (_x,_y) in ((:sin,:sind), (:cos,:cosd), (:tan,:tand),
        (:sec,:secd), (:csc,:cscd), (:cot,:cotd))
    @eval ($_x){T}(x::Quantity{T,typeof(NoDims),typeof(°)}) = ($_y)(ustrip(x))
    @eval ($_y){T}(x::Quantity{T,typeof(NoDims),typeof(°)}) = ($_y)(ustrip(x))
end

# Temperature
@unit °Ra    "°Ra"      Rankine     (5//9)*K                false
@unit °C     "°C"       Celsius     1K                      true
offsettemp(::Unit{:Celsius}) = 27315//100
@unit °F     "°F"       Fahrenheit  (5//9)*K                false
offsettemp(::Unit{:Fahrenheit}) = 45967//100

# SI and related units
@unit N      "N"        Newton      1kg*m/s^2               true
@unit Pa     "Pa"       Pascal      1N/m^2                  true
@unit J      "J"        Joule       1N*m                    true
@unit W      "W"        Watt        1J/s                    true
@unit C      "C"        Coulomb     1A*s                    true
@unit V      "V"        Volt        1W/A                    true
@unit Hz     "Hz"       Hertz       1/s                     true
const q = 1.6021766208e-19*C        # CODATA 2014; `e` means 2.718...
@unit eV     "eV"       eV          q*V                     true
@unit Ω      "Ω"        Ohm         1V/A                    true
@unit S      "S"        Siemens     1/Ω                     true
@unit F      "F"        Farad       1s^4*A^2/(kg*m^2)       true
@unit H      "H"        Henry       1J/(A^2)                true
@unit T      "T"        Tesla       1kg/(A*s^2)             true
@unit Wb     "Wb"       Weber       1kg*m^2/(A*s^2)         true
@unit lm     "lm"       Lumen       1cd*sr                  true
@unit lx     "lx"       Lux         1lm/m^2                 true
@unit Bq     "Bq"       Becquerel   1/s                     true
@unit Gy     "Gy"       Gray        1J/kg                   true
@unit Sv     "Sv"       Sievert     1J/kg                   true
@unit kat    "kat"      Katal       1mol/s                  true

# Some non-SI pressure units
@unit bar    "bar"      Bar         100000Pa                true
@unit atm    "atm"      Atmosphere  101325Pa                false
@unit Torr   "Torr"     Torr        101325Pa//760           true

# Constants (2014 CODATA values)    (uncertainties in final digits)
const c0 = 299_792_458*m/s          # exact
const c  = c0
const μ0 = 4π*(1//10)^7*H/m         # exact (but gets promoted to Float64...)
const µ0 = μ0                       # magnetic constant
const ɛ0 = 1/(μ0*c^2)               # exact, electric constant
const ϵ0 = ɛ0
const Z0 = μ0*c                     # exact, impedance of free space
const G  = 6.674_08e-11*m^3/kg/s^2  # (31) gravitational constant
const h  = 6.626_070_040e-34*J*s    # (81) Planck constant
const ħ  = h/2π                     # hbar
const q  = 1.602_176_620_8e-19*C    # (98)  `e` means 2.718... so we use q
                                    # elementary charge
const Φ0 = h/(2q)                   # Superconducting magnetic flux quantum
const me = 9.109_383_56e-31*kg      # (11) electron rest mass
const mn = 1.674_927_471e-27*kg     # (21) neutron rest mass
const mp = 1.672_621_898e-27*kg     # (21) proton rest mass
const μB = e*ħ/(2*me)               # Bohr magneton
const µB = μB
const Na = 6.022_140_857e23/mol     # (74) Avogadro constant
const R  = 8.314_459_8*J/(mol*K)    # (48) molar gass constant
const k  = 1.380_648_52e-23*(J/K)   # (79) Boltzmann constant
const σ  = π^2*k^4/(60*ħ^3*c^2)     # Stefan-Boltzmann constant

# Promotion rules

# By default, pick the units specified by the @preferunit macro.
# Our use of promote_rule here is only via promote_type;
# We will never be promoting unit objects themselves.
function promote_rule{S<:Units,T<:Units}(::Type{S}, ::Type{T})
    dS = dimension(S())
    dT = dimension(T())
    dS != dT && error("Dimensions are unequal in call to `promote_rule`.")
    typeof(upreferred(dS))
end

# You could also add rules like the following, which will not interfere with
# the generic behavior for other dimensions:
promote_rule{S<:EnergyUnit, T<:EnergyUnit}(::Type{S}, ::Type{T}) = typeof(J)
promote_rule{S<:ForceUnit, T<:ForceUnit}(::Type{S}, ::Type{T}) = typeof(N)
promote_rule{S<:PowerUnit, T<:PowerUnit}(::Type{S}, ::Type{T}) = typeof(W)
promote_rule{S<:PressureUnit, T<:PressureUnit}(::Type{S}, ::Type{T}) = typeof(Pa)
promote_rule{S<:ChargeUnit, T<:ChargeUnit}(::Type{S}, ::Type{T}) = typeof(C)
promote_rule{S<:VoltageUnit, T<:VoltageUnit}(::Type{S}, ::Type{T}) = typeof(V)
promote_rule{S<:ResistanceUnit, T<:ResistanceUnit}(::Type{S}, ::Type{T}) = typeof(Ω)
promote_rule{S<:CapacitanceUnit, T<:CapacitanceUnit}(::Type{S}, ::Type{T}) = typeof(F)
promote_rule{S<:InductanceUnit, T<:InductanceUnit}(::Type{S}, ::Type{T}) = typeof(H)
promote_rule{S<:MagneticFluxUnit, T<:MagneticFluxUnit}(::Type{S}, ::Type{T}) = typeof(Wb)
promote_rule{S<:BFieldUnit, T<:BFieldUnit}(::Type{S}, ::Type{T}) = typeof(T)

#const si_no_prefix = (:m, :s, :A, :K, :cd, :g, :mol, :rad, :sr, :Hz, :N, :Pa,
#    :J, :W, :C, :V, :F, :Ω, :S, :Wb, :T, :H, :°C, :lm, :lx, :Bq, :Gy, :Sv, :kat)
#
## `using Unitful.SIUnits` will bring all the base and derived SI units,
## with SI prefixes, into the calling namespace.
#baremodule SIUnits
#    import Unitful
#    import Unitful: si_no_prefix
#
#    # The following line has two different character encodings for μ
#    for p in (:y, :z, :a, :f, :p, :n, :μ, :µ, :m, :c, :d,
#        Symbol(""), :da, :h, :k, :M, :G, :T, :P, :E, :Z, :Y)
#        for u in si_no_prefix
#            eval(SIUnits, Expr(:import, :Unitful, Symbol(p,u)))
#            eval(SIUnits, Expr(:export, Symbol(p,u)))
#        end
#    end
#end

"""
```
macro u_str(unit)
```

String macro to easily recall units, dimensions, or quantities defined in the
Unitful module, which does not export such things to avoid namespace pollution.
Note that for now, what goes inside must be parsable as a valid Julia expression.
In other words, u"N m" will fail if you intended to write u"N*m".

Examples:

```jldoctest
julia> 1.0u"m/s"
1.0 m s^-1

julia> 1.0u"N*m"
1.0 m N

julia> typeof(1.0u"m/s")
Quantity{Float64, Dimensions:{𝐋 𝐓^-1}, Units:{m s^-1}}

julia> u"ħ"
1.0545718001391127e-34 J s
```
"""
macro u_str(unit)
    ex = parse(unit)
    replace_value(ex)
end

const allowed_funcs = [:*, :/, :^, :sqrt, :√, :+, :-, ://]
function replace_value(ex::Expr)
    ex.head != :call && error("$(ex.head) != :call")
    ex.args[1] in allowed_funcs ||
        error("""$(ex.args[1]) is not a valid function call when parsing a unit.
         Only the following functions are allowed: $allowed_funcs""")
    for i=2:length(ex.args)
        if typeof(ex.args[i])==Symbol || typeof(ex.args[i])==Expr
            ex.args[i]=replace_value(ex.args[i])
        end
    end
    ex
end

replace_value(sym::Symbol) = :(ustrcheck($(current_module()).$sym))
ustrcheck(x::Unitlike) = x
ustrcheck(x::Quantity) = x
ustrcheck(x) = error("Unexpected symbol in unit macro.")

end
