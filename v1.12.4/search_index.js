var documenterSearchIndex = {"docs":
[{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"DocTestSetup = quote\n    using Unitful\nend","category":"page"},{"location":"logarithm/#Logarithmic-scales","page":"Logarithmic scales","title":"Logarithmic scales","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"note: Note\nLogarithmic scales are new to Unitful and should be considered experimental.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Unitful provides a way to use logarithmically-scaled quantities as of v0.4.0. Some compromises have been made in striving for logarithmic quantities to be both usable and consistent. In the following discussion, for pedagogical purposes, we will assume prior familiarity with the definitions of dB and dBm.","category":"page"},{"location":"logarithm/#Constructing-logarithmic-quantities","page":"Logarithmic scales","title":"Constructing logarithmic quantities","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Left- or right-multiplying a pure number by a logarithmic \"unit\", whether dimensionful or dimensionless, is short-hand for constructing a logarithmic quantity.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> 3u\"dB\"\n3 dB\n\njulia> 3u\"dBm\"\n3.0 dBm\n\njulia> u\"dB\"*3 === 3u\"dB\"\ntrue","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Currently implemented are dB, B, dBm, dBV, dBu, dBμV, dBSPL, dBFS, cNp, Np.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"One can also construct logarithmic quantities using the @dB, @B, @cNp, @Np macros to use an arbitrary reference level:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> using Unitful: mW, V\n\njulia> @dB 10mW/mW\n10.0 dBm\n\njulia> @dB 10V/V\n20.0 dBV\n\njulia> @dB 3V/4V\n-2.498774732165999 dB (4 V)\n\njulia> @Np ℯ*V/V    # ℯ = 2.71828...\n1.0 Np (1 V)","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"These macros are exported by default since empirically macros are defined less often than variables and generic functions. When using the macros, the levels are constructed at parse time. The scales themselves are callable as functions if you need to construct a level that way (they are not exported):","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> using Unitful: dB, mW, V\n\njulia> dB(10mW,mW)\n10.0 dBm","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"In calculating the logarithms, the log function appropriate to the scale in question is used (log10 for decibels, log for nepers).","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"There is an important difference in these two approaches to constructing logarithmic quantities. When we construct 0dBm, the power in mW is calculated and stored, resulting in a lossy floating-point conversion. This can be avoided by constructing 0 dBm as @dB 1mW/mW.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"It is important to keep in mind that the reference level is just used to calculate the logarithms, and nothing more. When there is ambiguity about what to do, we fall back to the underlying linear quantities, paying no mind to the reference levels:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> using Unitful: mW\n\njulia> (@dB 10mW/1mW) + (@dB 10mW/2mW)\n20 mW","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Addition will be discussed more later.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Note that logarithmic \"units\" can only multiply or be multiplied by pure numbers and linear units, not other logarithmic units or quantities. This is done to avoid issues with commutativity and associativity, e.g. 3*dB*m^-1 == (3dB)/m, but 3*m^-1*dB == (3m^-1)*dB does not make much sense. This is because dB acts more like a constructor than a proper unit.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"The @dB and @Np macros will fail if either a dimensionless number or a ratio of dimensionless numbers is used. This is because the ratio could be of power quantities or of root-power quantities, leading to ambiguities. After all, usually it is the ratio that is dimensionless, not the numerator and denominator that make up the ratio. In some cases it may nonetheless be convenient to have a dimensionless reference level. By providing an extra Bool argument to these macros, you can explicitly choose whether the resulting ratio should be considered a \"root-power\" or \"power\" ratio. You can only do this for dimensionless numbers:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> @dB 10/1 true   # is a root-power (amplitude) ratio\n20.0 dBFS\n\njulia> @dB 10/1 false  # is not a root-power ratio; is a power ratio\n10.0 dB (power ratio with reference 1)","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Note that dBFS is defined to represent amplitudes relative to 1 in dB, hence the custom display logic.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Also, you can of course use functions instead of macros:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> using Unitful: dB, mW\n\njulia> dB(10,1,true)\n20.0 dBFS\n\njulia> dB(10mW,mW,true)\nERROR: ArgumentError: when passing a final Bool argument, this can only be used with dimensionless numbers.\n[...]","category":"page"},{"location":"logarithm/#Logarithmic-quantities-with-no-reference-level-specified","page":"Logarithmic scales","title":"Logarithmic quantities with no reference level specified","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Logarithmic quantities with no reference level specified typically represent some amount of gain or attenuation, i.e. a ratio which is dimensionless. These can be constructed as, for example, 10*dB, which displays similarly (10 dB). The type of this kind of logarithmic quantity is:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"    Unitful.Gain","category":"page"},{"location":"logarithm/#Unitful.Gain","page":"Logarithmic scales","title":"Unitful.Gain","text":"struct Gain{L, S, T<:Real} <: LogScaled{L}\n\nA logarithmic scale-based gain or attenuation factor. This type has one field, val::T. For example, given a gain of 20dB, we have val===20. This type differs from Unitful.Level in that val is stored after computing the logarithm.\n\n\n\n\n\n","category":"type"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"One might expect that any gain / attenuation factor should be convertible to a pure number, that is, to x == y/z if you had 10*log10(x) dB. However, it turns out that in dB, a ratio of powers is defined as 10*log10(y/z), but a ratio of voltages or other root-power quantities is defined as 20*log10(y/z). Clearly, converting back from decibels to a real number is ambiguous, and so we have not implemented automatic promotion to avoid incorrect results. You can use Unitful.uconvertp to interpret a Gain as a ratio of power quantities (hence the p in uconvertp), or Unitful.uconvertrp to interpret as a ratio of root-power (field) quantities.","category":"page"},{"location":"logarithm/#\"Dimensionful\"-logarithmic-quantities?","page":"Logarithmic scales","title":"\"Dimensionful\" logarithmic quantities?","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"In this package, quantities with units like dBm are considered to have the dimension of power, even though the expression P(dBm) = 10*log10(P/1mW) is dimensionless and formed from a dimensionless ratio. Practically speaking, these kinds of logarithmic quantities are fungible whenever they share the same dimensions, so it is more convenient to adopt this convention (people refer to dBm/Hz as a power spectral density, etc.) Presumably, one would like to have 10dBm isa Unitful.Power for dispatch too. Therefore, in the following discussion, we will shamelessly (okay, with some shame) speak of dimensionful logarithmic quantities, or Levels for short:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"    Unitful.Level","category":"page"},{"location":"logarithm/#Unitful.Level","page":"Logarithmic scales","title":"Unitful.Level","text":"struct Level{L, S, T<:Union{Real, AbstractQuantity{<:Real}}} <: LogScaled{L}\n\nA logarithmic scale-based level. Details about the logarithmic scale are encoded in L <: LogInfo. S is a reference quantity for the level, not a type. This type has one field, val::T, and the log of the ratio val/S is taken. This type differs from Unitful.Gain in that val is a linear quantity.\n\n\n\n\n\n","category":"type"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Actually, the defining characteristic of a Level is that it has a reference level, which may or may not be dimensionful. It usually is, but is not in the case of e.g. dBFS.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Finally, for completeness we note that both Level and Gain are subtypes of LogScaled:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"    Unitful.LogScaled","category":"page"},{"location":"logarithm/#Unitful.LogScaled","page":"Logarithmic scales","title":"Unitful.LogScaled","text":"abstract type LogScaled{L<:LogInfo} <: Number end\n\nAbstract supertype of Unitful.Level and Unitful.Gain. It is only used in promotion to put levels and gains onto a common log scale.\n\n\n\n\n\n","category":"type"},{"location":"logarithm/#Multiplication-rules","page":"Logarithmic scales","title":"Multiplication rules","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Multiplying a dimensionless logarithmic quantity by a pure number acts as like it does for linear quantities:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> 3u\"dB\" * 2\n6 dB\n\njulia> 2 * 0u\"dB\"\n0 dB","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Justification by example: consider the example of the exponential attenuation of a signal on a lossy transmission line. If the attenuation goes like 10^-kx, then the (power) attenuation in dB is -10kx. We see that the attenuation in dB is linear in length. For an attenuation constant of 3dB/m, we better calculate 6dB for a length of 2m.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Multiplying a dimensionful logarithmic quantity by a pure number acts differently than multiplying a gain/attenuation by a pure number. Since 0dBm == 1mW, we better have that 0dBm * 2 == 2mW, implying:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> 0u\"dBm\" * 2\n3.010299956639812 dBm","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Logarithmic quantities can only be multiplied by pure numbers, linear units, or quantities, but not logarithmic \"units\" or quantities.  When a logarithmic quantity is multiplied by a linear quantity, the logarithmic quantity is linearized and multiplication proceeds as usual:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> (0u\"dBm\") * (1u\"W\")\n1.0 mW W","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"The previous example returns a floating point value because in constructing the level 0 dBm, the power in mW is calculated and stored, entailing a floating point conversion. This can be avoided by constructing 0 dBm as @dB 1mW/mW:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> (@dB 1u\"mW\"/u\"mW\") * (1u\"W\")\n1 mW W","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"We refer to a quantity with both logarithmic \"units\" and linear units as a mixed quantity. For mixed quantities, the numeric value associates with the logarithmic unit, and the quantity is displayed in a way that makes this explicit:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> (0u\"dBm\")/u\"Hz\"\n[0.0 dBm] Hz^-1\n\njulia> (0u\"dB\")/u\"Hz\"\n[0 dB] Hz^-1\n\njulia> 0u\"dB/Hz\"\n[0 dB] Hz^-1","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Mathematical operations are forwarded to the logarithmic part, so that for example, 100*((0dBm)/s) == (20dBm)/s. We allow linear units to commute with logarithmic quantities for convenience, though the association is understood (e.g. s^-1*(3dBm) == (3dBm)/s).","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"The behavior of multiplication is summarized in the following table, with entries marked by † indicate prohibited operations. This table is populated automatically whenever the docs are built.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"using Latexify, Unitful\nhead = [\"10\", \"Hz^-1\", \"dB\", \"dBm\", \"1/Hz\", \"1mW\", \"3dB\", \"3dBm\"]\nside = [\"*\"; \"**\" .* head .* \"**\"]\nquantities = uparse.(head)\ntab = fill(\"\", length(head), length(head))\nfor col = eachindex(head), row = 1:col\n    try\n        tab[row, col] = string(quantities[row] * quantities[col])\n    catch\n        if quantities[row] === u\"1/Hz\" && quantities[col] === u\"3dB\"\n            tab[row, col] = \"† ‡\"\n        else\n            tab[row, col] = \"†\"\n        end\n    end\nend\nmdtable(tab, latex=false, head=head, side=side)","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"‡: 1/Hz * 3dB could be allowed, technically, but we throw an error if it's unclear whether a quantity is a root-power or power quantity:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> u\"1/Hz\" * u\"3dB\"\nERROR: undefined behavior. Please file an issue with the code needed to reproduce.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"On the other hand, if it can be determined that a power quantity or root-power quantity is being multiplied by a gain, then the gain is interpreted as a power ratio or root-power ratio, respectively:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> 1u\"mW\" * 20u\"dB\"\n100.0 mW\n\njulia> 1u\"V\" * 20u\"dB\"\n10.0 V","category":"page"},{"location":"logarithm/#Addition-rules","page":"Logarithmic scales","title":"Addition rules","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"We can add logarithmic quantities without reference levels specified (Gains):","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> 20u\"dB\" + 20u\"dB\"\n40 dB","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"The numbers out front of the dB just add: when we talk about gain or attenuation, we work in logarithmic units so that we can add rather than multiply gain factors. The same behavior holds when we add a Gain to a Level or vice versa:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> 20u\"dBm\" + 20u\"dB\"\n40.0 dBm","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"In the case where you have differing logarithmic scales for the Level and the Gain, the logarithmic scale of the Level is used for the result:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> 10u\"dBm\" - 1u\"Np\"\n1.3141103619349632 dBm","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"For logarithmic quantities with the same reference levels, the numbers out in front do not simply add:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> 20u\"dBm\" + 20u\"dBm\"\n23.010299956639813 dBm\n\njulia> 2 * 20u\"dBm\"\n23.010299956639813 dBm","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"This is because dBm represents a power, ultimately. If we have some amount of power and we double it, we'd better get roughly 3 dB more power. Note that the juxtaposition 20dBm will ensure that 20 dBm is constructed before multiplication by 2 in the above example. If you were to type 2*20*dBm, you'd get 40 dBm.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"If the reference levels differ but both levels represent a power, we fall back to linear quantities:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> 20u\"dBm\" + @dB 1u\"W\"/u\"W\"\n1.1 kg m^2 s^-3","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"i.e. 1.1 W.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Rules for addition are summarized in the following table, with entries marked by † indicating prohibited operations. This table is populated automatically whenever the docs are built.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"using Latexify, Unitful\nhead = [\"100\", \"20dB\", \"1Np\", \"10.0dBm\", \"10.0dBV\", \"1mW\"]\nside = [\"+\"; \"**\" .* head .* \"**\"]\nquantities = uparse.(head)\ntab = fill(\"\", length(head), length(head))\nfor col = eachindex(head), row = 1:col\n    try\n        tab[row, col] = string(quantities[row] + quantities[col])\n    catch\n        tab[row, col] = \"†\"\n    end\nend\nmdtable(tab, latex=false, head=head, side=side)","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Notice that we disallow implicit conversions between dimensionless logarithmic quantities and real numbers. This is because the results can depend on promotion rules in addition to being ambiguous because of the root-power vs. power ratio issue. If 100 + 10dB were evaluated as 20dB + 10dB == 30dB, then we'd get 1000, but if it were evaluated as 100+10, we'd get 110.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Also, although it is possible in principle to add e.g. 20dB + 1Np, notice that we have not implemented that because it is unclear whether the result should be in nepers or decibels, and it is also unclear how to handle that question more generally as other logarithmic scales are introduced.","category":"page"},{"location":"logarithm/#Conversion","page":"Logarithmic scales","title":"Conversion","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"As alluded to earlier, conversions can be tricky because so-called logarithmic units are not units in the conventional sense.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"You may use linear to convert to a linear scale when you have a Level or Quantity{<:Level} type. There is a fallback for Number, which just returns the number.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> linear(@dB 10u\"mW\"/u\"mW\")\n10 mW\n\njulia> linear(20u\"dBm/Hz\")\n100.0 mW Hz^-1\n\njulia> linear(30u\"W\")\n30 W\n\njulia> linear(12)\n12","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"Linearizing a Quantity{<:Gain} or a Gain to a real number is ambiguous, because the real number may represent a ratio of powers or a ratio of root-power (field) quantities. We implement Unitful.uconvertp and Unitful.uconvertrp which may be thought of as disambiguated uconvert functions. There is a one argument version that assumes you are converting to a unitless number. These functions can take either a Gain or a Real so that they may be used somewhat generically.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"julia> uconvertrp(NoUnits, 20u\"dB\")\n10.0\n\njulia> uconvertp(NoUnits, 20u\"dB\")  \n100.0\n\njulia> uconvertp(u\"dB\", 100)\n20.0 dB\n\njulia> uconvertp(u\"Np\", ℯ^2)\n1.0 Np\n\njulia> uconvertrp(u\"Np\", ℯ)\n1//1 Np","category":"page"},{"location":"logarithm/#Notation","page":"Logarithmic scales","title":"Notation","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"This package displays logarithmic quantities using shorthand like dBm where available. This should probably not be done in polite company. To quote \"Guide for the Use of the International System of Units (SI),\" NIST Special Pub. 811 (2008):","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"The rules of Ref. [5: IEC 60027-3] preclude, for example, the use of the symbol dBm to indicate a reference level of power of 1 mW. This restriction is based on the rule of Sec. 7.4, which does not permit attachments to unit symbols.","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"The authorities say the reference level should always specified. In practice, this hasn't stopped the use of dBm and the like on commercially available test equipment. Dealing with these units is unavoidable in practice. When no shorthand exists, we follow NIST's advice in displaying logarithmic quantities:","category":"page"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"When such data are presented in a table or in a figure, the following condensed notation may be used instead: -0.58 Np (1 μV/m); 25 dB (20 μPa).","category":"page"},{"location":"logarithm/#Custom-logarithmic-scales","page":"Logarithmic scales","title":"Custom logarithmic scales","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"    Unitful.@logscale","category":"page"},{"location":"logarithm/#Unitful.@logscale","page":"Logarithmic scales","title":"Unitful.@logscale","text":"@logscale(symb,abbr,name,base,prefactor,irp)\n\nDefine a logarithmic scale. Unlike with units, there is no special treatment for power-of-ten prefixes (decibels and bels are defined separately). However, arbitrary bases are possible, and computationally appropriate log and exp functions are used in calculations when available (e.g. log2, log10 for base 2 and base 10, respectively).\n\nThis macro defines a MixedUnits object identified by symbol symb. This can be used to construct Gain types, e.g. 3*dB. Additionally, two other MixedUnits objects are defined, with symbols Symbol(symb,\"_rp\") and Symbol(symb,\"_p\"), e.g. dB_rp and dB_p, respectively. These objects serve nearly the same purpose, but have extra information in their type that indicates whether they should be considered as root-power ratios or power ratios upon conversion to pure numbers.\n\nThis macro also defines another macro available as @symb. For example, @dB in the case of decibels. This can be used to construct Level objects at parse time. Usage is like @dB 3V/1V.\n\nprefactor is the prefactor out in front of the logarithm for this log scale. In all cases it is defined with respect to taking ratios of power quantities. Just divide by two if you want to refer to root-power / field quantities instead.\n\nirp (short for \"is root power?\") specifies whether the logarithmic scale is defined with respect to ratios of power or root-power quantities. In short: use false if your scale is decibel-like, or true if your scale is neper-like.\n\nExamples:\n\njulia> using Unitful: V, W\n\njulia> @logscale dΠ \"dΠ\" Decipies π 10 false\ndΠ\n\njulia> @dΠ π*V/1V\n20.0 dΠ (1 V)\n\njulia> dΠ(π*V, 1V)\n20.0 dΠ (1 V)\n\njulia> @dΠ π^2*V/1V\n40.0 dΠ (1 V)\n\njulia> @dΠ π*W/1W\n10.0 dΠ (1 W)\n\n\n\n\n\n","category":"macro"},{"location":"logarithm/#API","page":"Logarithmic scales","title":"API","text":"","category":"section"},{"location":"logarithm/","page":"Logarithmic scales","title":"Logarithmic scales","text":"    Unitful.linear\n    Unitful.reflevel\n    Unitful.uconvertp\n    Unitful.uconvertrp","category":"page"},{"location":"logarithm/#Unitful.linear","page":"Logarithmic scales","title":"Unitful.linear","text":"linear(x::Quantity)\nlinear(x::Level)\nlinear(x::Number) = x\n\nReturns a quantity equivalent to x but without any logarithmic scales.\n\nIt is important to note that this operation will error for Quantity{<:Gain} types. This is for two reasons:\n\n20dB could be interpreted as either a power or root-power ratio.\nEven if -20dB/m were interpreted as, say, 0.01/m, this means something fundamentally different than -20dB/m. 0.01/m cannot be used to calculate exponential attenuation.\n\n\n\n\n\n","category":"function"},{"location":"logarithm/#Unitful.reflevel","page":"Logarithmic scales","title":"Unitful.reflevel","text":"reflevel(x::Level{L,S})\nreflevel(::Type{Level{L,S}})\nreflevel(::Type{Level{L,S,T}})\n\nReturns the reference level, e.g.\n\njulia> reflevel(3u\"dBm\")\n1 mW\n\n\n\n\n\n","category":"function"},{"location":"logarithm/#Unitful.uconvertp","page":"Logarithmic scales","title":"Unitful.uconvertp","text":"uconvertp(u::Units, x)\nuconvertp(u::MixedUnits, x)\n\nGenerically, this is the same as Unitful.uconvert. In cases where unit conversion would be ambiguous without further information (e.g. uconvert(dB, 10)), uconvertp presumes ratios are of power quantities.\n\nIt is important to note that careless use of this function can lead to erroneous calculations. Consider Quantity{<:Gain} types: it is tempting to use this to transform -20dB/m into 0.1/m, however this means something fundamentally different than -20dB/m. Consider what happens when you try to compute exponential attenuation by multiplying 0.1/m by a length.\n\nExamples:\n\njulia> using Unitful\n\njulia> uconvertp(u\"dB\", 10)\n10.0 dB\n\njulia> uconvertp(NoUnits, 20u\"dB\")\n100.0\n\n\n\n\n\n","category":"function"},{"location":"logarithm/#Unitful.uconvertrp","page":"Logarithmic scales","title":"Unitful.uconvertrp","text":"uconvertrp(u::Units, x)\nuconvertrp(u::MixedUnits, x)\n\nIn most cases, this is the same as Unitful.uconvert. In cases where unit conversion would be ambiguous without further information (e.g. uconvert(dB, 10)), uconvertrp presumes ratios are of root-power quantities.\n\nIt is important to note that careless use of this function can lead to erroneous calculations. Consider Quantity{<:Gain} types: it is tempting to use this to transform -20dB/m into 0.01/m, however this means something fundamentally different than -20dB/m. Consider what happens when you try to compute exponential attenuation by multiplying 0.01/m by a length.\n\n\n\n\n\n","category":"function"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"DocTestSetup = quote\n    using Unitful\nend","category":"page"},{"location":"trouble/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"trouble/#Why-do-unit-conversions-yield-rational-numbers-sometimes?","page":"Troubleshooting","title":"Why do unit conversions yield rational numbers sometimes?","text":"","category":"section"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"We use rational numbers in this package to permit exact conversions between different units where possible. As an example, one inch is exactly equal to 2.54 cm. However, in Julia, the floating-point 2.54 is not equal to 254//100. As a consequence, 1inch != 2.54cm, because Unitful respects exact conversions. To test for equivalence, instead use ≈ (\\approx tab-completion).","category":"page"},{"location":"trouble/#But-I-want-a-floating-point-number...","page":"Troubleshooting","title":"But I want a floating point number...","text":"","category":"section"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"float(x) is defined for Unitful.Quantity types, and is forwarded to the underlying numeric type (units are not affected).","category":"page"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"We may consider adding an option in the defaults to turn on/off use of Rational numbers. They permit exact conversions, but they aren't preferred as a result type in much of Julia Base (consider that inv(2) === 0.5, not 1//2).","category":"page"},{"location":"trouble/#Exponentiation","page":"Troubleshooting","title":"Exponentiation","text":"","category":"section"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"Most operations with this package should in principle suffer little performance penalty if any at run time. An exception to this is rule is exponentiation. Since units and their powers are encoded in the type signature of a Unitful.Quantity object, raising a Quantity to some power, which is just some run-time value, necessarily results in different result types. This type instability could impact performance:","category":"page"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"julia> square(x) = (p = 2; x^p)\nsquare (generic function with 1 method)","category":"page"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"In Julia, constant literal integers are lowered specially for exponentiation. (See Julia PR #20530 for details.) In this case, type stability can be maintained:","category":"page"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"julia> square(x) = x^2\nsquare (generic function with 1 method)","category":"page"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"Because the functions inv, sqrt, and cbrt are raising a Quantity to a fixed power (-1, 1/2, and 1/3, respectively), we can use a generated function to ensure type stability in these cases. Also note that squaring a Quantity can be type-stable if done as x*x.","category":"page"},{"location":"trouble/#Promotion-with-dimensionless-numbers","page":"Troubleshooting","title":"Promotion with dimensionless numbers","text":"","category":"section"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"Most of the time, you are only permitted to do sensible operations in Unitful. With dimensionless numbers, some of the safe logic breaks down. Consider for instance that μm/m and rad are both dimensionless units, but kind of have nothing to do with each other. It would be a little weird to add them. Nonetheless, we permit this to happen since they have the same dimensions. Otherwise, we would have to special-case operations for two dimensionless quantities rather than dispatching on the empty dimension.","category":"page"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"The result of addition and subtraction with dimensionless but unitful numbers is always a pure number with no units. With angles, 1 rad is essentially just 1, giving sane behavior:","category":"page"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"julia> π/2*u\"rad\"+90u\"°\"\n3.141592653589793","category":"page"},{"location":"trouble/#Broken-display-of-dimension-characters-in-the-REPL","page":"Troubleshooting","title":"Broken display of dimension characters in the REPL","text":"","category":"section"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"On some terminals with some fonts, dimension characters such as 𝐌 are displayed as an empty box. Setting a wider font spacing in your terminal settings can solve this problem.","category":"page"},{"location":"trouble/#I-have-a-different-problem","page":"Troubleshooting","title":"I have a different problem","text":"","category":"section"},{"location":"trouble/","page":"Troubleshooting","title":"Troubleshooting","text":"Please raise an issue. This package is in development and there may be bugs. Feature requests may also be considered and pull requests are welcome.","category":"page"},{"location":"display/#How-units-are-displayed","page":"How units are displayed","title":"How units are displayed","text":"","category":"section"},{"location":"display/","page":"How units are displayed","title":"How units are displayed","text":"By default, exponents on units or dimensions are indicated using Unicode superscripts on macOS and without superscripts on other operating systems. You can set the environment variable UNITFUL_FANCY_EXPONENTS to either true or false to force using or not using the exponents. You can also set the :fancy_exponent IO context property to either true or false to force using or not using the exponents.","category":"page"},{"location":"display/","page":"How units are displayed","title":"How units are displayed","text":"Unitful.BracketStyle\nUnitful.abbr\nUnitful.prefix\nUnitful.show(::IO, ::Quantity)\nUnitful.show(::IO, ::Unitful.Unitlike)\nUnitful.showrep\nUnitful.showval\nUnitful.superscript","category":"page"},{"location":"display/#Unitful.BracketStyle","page":"How units are displayed","title":"Unitful.BracketStyle","text":"BracketStyle(x)\nBracketStyle(typeof(x))\n\nBracketStyle specifies whether the numeric value of a Quantity is printed in brackets (and what kind of brackets). Three styles are defined:\n\nNoBrackets(): this is the default, for example used for real numbers: 1.2 m\nRoundBrackets(): used for complex numbers: (2.5 + 1.0im) V\nSquareBrackets(): used for Level/Gain: [3 dB] Hz^-1\n\n\n\n\n\n","category":"type"},{"location":"display/#Unitful.abbr","page":"How units are displayed","title":"Unitful.abbr","text":"abbr(x) provides abbreviations for units or dimensions. Since a method should always be defined for each unit and dimension type, absence of a method for a specific unit or dimension type is likely an error. Consequently, we return ❓ for generic arguments to flag unexpected behavior.\n\n\n\n\n\n","category":"function"},{"location":"display/#Unitful.prefix","page":"How units are displayed","title":"Unitful.prefix","text":"prefix(x::Unit)\n\nReturns a string representing the SI prefix for the power-of-ten held by this particular unit.\n\n\n\n\n\n","category":"function"},{"location":"display/#Base.show-Tuple{IO, Quantity}","page":"How units are displayed","title":"Base.show","text":"show(io::IO, x::Quantity)\n\nShow a unitful quantity by calling showval on the numeric value, appending a space, and then calling show on a units object U().\n\n\n\n\n\n","category":"method"},{"location":"display/#Base.show-Tuple{IO, Unitful.Unitlike}","page":"How units are displayed","title":"Base.show","text":"show(io::IO, x::Unitlike)\n\nCall Unitful.showrep on each object in the tuple that is the type variable of a Unitful.Units or Unitful.Dimensions object.\n\n\n\n\n\n","category":"method"},{"location":"display/#Unitful.showrep","page":"How units are displayed","title":"Unitful.showrep","text":"showrep(io::IO, x::Unit)\n\nShow the unit, prefixing with any decimal prefix and appending the exponent as formatted by Unitful.superscript.\n\n\n\n\n\nshowrep(io::IO, x::Dimension)\n\nShow the dimension, appending any exponent as formatted by Unitful.superscript.\n\n\n\n\n\n","category":"function"},{"location":"display/#Unitful.showval","page":"How units are displayed","title":"Unitful.showval","text":"showval(io::IO, x::Number, brackets::Bool=true)\n\nShow the numeric value x of a quantity. Depending on the type of x, the value may be enclosed in brackets (see BracketStyle). If brackets is set to false, the brackets are not printed.\n\n\n\n\n\n","category":"function"},{"location":"display/#Unitful.superscript","page":"How units are displayed","title":"Unitful.superscript","text":"superscript(i::Rational; io::Union{IO, Nothing} = nothing)\n\nReturns exponents as a string.\n\nThis function returns the value as a string. It does not print to io. io is only used for IO context values. If io contains the :fancy_exponent property and the value is a Bool, this value will override the behavior of fancy exponents.\n\n\n\n\n\n","category":"function"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"DocTestSetup = quote\n    using Unitful\nend","category":"page"},{"location":"newunits/#Defining-new-units","page":"Defining new units","title":"Defining new units","text":"","category":"section"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"note: Note\nLogarithmic units should not be used in the @refunit or @unit macros described below. See the section on logarithmic scales for customization help.","category":"page"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"The package automatically generates a useful set of units and dimensions in the Unitful module in src/pkgdefaults.jl.","category":"page"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"If a different set of default units or dimensions is desired, macros for generating units and dimensions are provided. To create new units interactively, most users will be happy with the @unit macro and the Unitful.register function, which makes units defined in a module available to the @u_str string macro.","category":"page"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"An example of defining units in a module:","category":"page"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"julia> module MyUnits; using Unitful; @unit myMeter \"m\" MyMeter 1u\"m\" false; end\nMyUnits\n\njulia> using Unitful\n\njulia> u\"myMeter\"\nERROR: LoadError:\n[...]\n\njulia> Unitful.register(MyUnits);\n\njulia> u\"myMeter\"\nm","category":"page"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"You could have also called Unitful.register inside the MyUnits module; the choice is somewhat analogous to whether or not to export symbols from a module, although the symbols are never really exported, just made available to the @u_str macro. If you want to make a precompiled units package, rather than define a module at the REPL, see Making your own units package.","category":"page"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"You can also define units directly in the Main module at the REPL:","category":"page"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"julia> using Unitful\n\njulia> Unitful.register(@__MODULE__);\n\njulia> @unit M \"M\" Molar 1u\"mol/L\" true;\n\njulia> 1u\"mM\"\n1 mM","category":"page"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"A note for the experts: Some care should be taken if explicitly creating Unitful.Units objects. The ordering of Unitful.Unit objects inside a tuple matters for type comparisons. Using the unary multiplication operator on the Units object will return a \"canonically sorted\" Units object. Indeed, this is how we avoid ordering issues when multiplying quantities together.","category":"page"},{"location":"newunits/#Defining-units-in-precompiled-packages","page":"Defining new units","title":"Defining units in precompiled packages","text":"","category":"section"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"See Precompilation.","category":"page"},{"location":"newunits/#Useful-functions-and-macros","page":"Defining new units","title":"Useful functions and macros","text":"","category":"section"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"Unitful.@dimension\nUnitful.@derived_dimension\nUnitful.@refunit\nUnitful.@unit\nUnitful.@affineunit","category":"page"},{"location":"newunits/#Unitful.@dimension","page":"Defining new units","title":"Unitful.@dimension","text":"@dimension(symb, abbr, name, autodocs=false)\n\nCreates new dimensions. name will be used like an identifier in the type parameter for a Unitful.Dimension object. symb will be a symbol defined in the namespace from which this macro is called that is bound to a Unitful.Dimensions object. For most intents and purposes it is this object that the user would manipulate in doing dimensional analysis. The symbol is not exported.\n\nThis macro extends Unitful.abbr to display the new dimension in an abbreviated format using the string abbr.\n\nType aliases are created that allow the user to dispatch on Unitful.Quantity, Unitful.Level and Unitful.Units objects of the newly defined dimension. The type alias for quantities or levels is simply given by name, and the type alias for units is given by name*\"Units\", e.g. LengthUnits. Note that there is also LengthFreeUnits, for example, which is an alias for dispatching on FreeUnits with length dimensions. The aliases are not exported. If autodocs == true, docstrings will be automatically generated for these aliases.\n\ncompat: Unitful 1.10\nDocumenting the resulting dimension symbol by adding a docstring before the @dimension call requires Unitful 1.10 or later. The autodocs argument also requires Unitful 1.10 or later.\n\nFinally, if you define new dimensions with @dimension you will need to specify a preferred unit for that dimension with Unitful.preferunits, otherwise promotion will not work with that dimension. This is done automatically in the @refunit macro.\n\nReturns the Dimensions object to which symb is bound.\n\nUsage example from src/pkgdefaults.jl: @dimension 𝐋 \"𝐋\" Length\n\n\n\n\n\n","category":"macro"},{"location":"newunits/#Unitful.@derived_dimension","page":"Defining new units","title":"Unitful.@derived_dimension","text":"@derived_dimension(name, dims, autodocs=false)\n\nCreates type aliases to allow dispatch on Unitful.Quantity, Unitful.Level, and Unitful.Units objects of a derived dimension, like area, which is just length squared. The type aliases are not exported. If autodocs == true, docstrings will be automatically generated for these aliases.\n\ncompat: Unitful 1.10\nThe autodocs argument requires Unitful 1.10 or later.\n\ndims is a Unitful.Dimensions object.\n\nReturns nothing.\n\nUsage examples:\n\n@derived_dimension Area 𝐋^2 gives Area and AreaUnit type aliases\n@derived_dimension Speed 𝐋/𝐓 gives Speed and SpeedUnit type aliases\n\n\n\n\n\n","category":"macro"},{"location":"newunits/#Unitful.@refunit","page":"Defining new units","title":"Unitful.@refunit","text":"@refunit(symb, abbr, name, dimension, tf, autodocs=false)\n\nDefine a reference unit, typically SI. Rather than define conversion factors between each and every unit of a given dimension, conversion factors are given between each unit and a reference unit, defined by this macro.\n\nThis macro extends Unitful.abbr so that the reference unit can be displayed in an abbreviated format. If tf == true, this macro generates symbols for every power of ten of the unit, using the standard SI prefixes. A dimension must be given (Unitful.Dimensions object) that specifies the dimension of the reference unit. If autodocs == true, autogenerated docstrings for SI-prefixed units will be added. This option has no effect when tf == false.\n\ncompat: Unitful 1.10\nDocumenting the resulting unit by adding a docstring before the @refunit call requires Unitful 1.10 or later. The autodocs argument also requires Unitful 1.10 or later.\n\nIn principle, users can use this macro, but it probably does not make much sense to do so. If you define a new (probably unphysical) dimension using @dimension, then this macro will be necessary. With existing dimensions, you will almost certainly cause confusion if you use this macro. One potential use case would be to define a unit system without reference to SI. However, there's no explicit barrier to prevent attempting conversions between SI and this hypothetical unit system, which could yield unexpected results.\n\nNote that this macro will also choose the new unit (no power-of-ten prefix) as the default unit for promotion given this dimension.\n\nReturns the Unitful.FreeUnits object to which symb is bound.\n\nUsage example: @refunit m \"m\" Meter 𝐋 true\n\nThis example, found in src/pkgdefaults.jl, generates km, m, cm, ...\n\n\n\n\n\n","category":"macro"},{"location":"newunits/#Unitful.@unit","page":"Defining new units","title":"Unitful.@unit","text":"@unit(symb,abbr,name,equals,tf,autodocs=false)\n\nDefine a unit. Rather than specifying a dimension like in @refunit, equals should be a Unitful.Quantity equal to one of the unit being defined. If tf == true, symbols will be made for each power-of-ten prefix. If autodocs == true, autogenerated docstrings for SI-prefixed units will be added. This option has no effect when tf == false.\n\ncompat: Unitful 1.10\nDocumenting the resulting unit by adding a docstring before the @unit call requires Unitful 1.10 or later. The autodocs argument also requires Unitful 1.10 or later.\n\nReturns the Unitful.FreeUnits object to which symb is bound.\n\nUsage example: @unit mi \"mi\" Mile (201168//125)*m false\n\nThis example will not generate kmi (kilomiles).\n\n\n\n\n\n","category":"macro"},{"location":"newunits/#Unitful.@affineunit","page":"Defining new units","title":"Unitful.@affineunit","text":"@affineunit(symb, abbr, offset)\n\nMacro for easily defining affine units. offset gives the zero of the relative scale in terms of an absolute scale; the scaling is the same as the absolute scale. Example: @affineunit °C \"°C\" (27315//100)K is used internally to define degrees Celsius.\n\ncompat: Unitful 1.10\nDocumenting the resulting unit by adding a docstring before the @affineunit call requires Unitful 1.10 or later.\n\n\n\n\n\n","category":"macro"},{"location":"newunits/#Internals","page":"Defining new units","title":"Internals","text":"","category":"section"},{"location":"newunits/","page":"Defining new units","title":"Defining new units","text":"Unitful.@prefixed_unit_symbols\nUnitful.@unit_symbols\nUnitful.basefactor","category":"page"},{"location":"newunits/#Unitful.@prefixed_unit_symbols","page":"Defining new units","title":"Unitful.@prefixed_unit_symbols","text":"@prefixed_unit_symbols(symb,name,dimension,basefactor,autodocs=false)\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units for each possible SI power-of-ten prefix on that unit. If autodocs == true, it will automatically generate docstrings for these units.\n\ncompat: Unitful 1.10\nDocumenting the resulting unit by adding a docstring before the @prefixed_unit_symbols call requires Unitful 1.10 or later. The autodocs argument also requires Unitful 1.10 or later.\n\nExample: @prefixed_unit_symbols m Meter 𝐋 (1.0,1) true results in nm, cm, m, km, ... all getting defined in the calling namespace, with docstrings automatically defined for SI-prefixed units.\n\n\n\n\n\n","category":"macro"},{"location":"newunits/#Unitful.@unit_symbols","page":"Defining new units","title":"Unitful.@unit_symbols","text":"@unit_symbols(symb,name)\n\nNot called directly by the user. Given a unit symbol and a unit's name, will define units without SI power-of-ten prefixes.\n\ncompat: Unitful 1.10\nDocumenting the resulting unit by adding a docstring before the @unit_symbols call requires Unitful 1.10 or later.\n\nExample: @unit_symbols ft Foot 𝐋 results in ft getting defined but not kft.\n\n\n\n\n\n","category":"macro"},{"location":"newunits/#Unitful.basefactor","page":"Defining new units","title":"Unitful.basefactor","text":"basefactor(x::Unit)\n\nSpecifies conversion factors to reference units. It returns a tuple. The first value is any irrational part of the conversion, and the second value is a rational component. This segregation permits exact conversions within unit systems that have no rational conversion to the reference units.\n\n\n\n\n\n","category":"function"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"DocTestSetup = quote\n    using Unitful\nend","category":"page"},{"location":"highlights/#Highlighted-features","page":"Highlighted features","title":"Highlighted features","text":"","category":"section"},{"location":"highlights/#Dispatch-on-dimensions","page":"Highlighted features","title":"Dispatch on dimensions","text":"","category":"section"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"Consider the following toy example, converting from voltage or power ratios to decibels:","category":"page"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"julia> whatsit(x::Unitful.Voltage) = \"voltage!\"\nwhatsit (generic function with 1 method)\n\njulia> whatsit(x::Unitful.Length) = \"length!\"\nwhatsit (generic function with 2 methods)\n\njulia> whatsit(1u\"mm\")\n\"length!\"\n\njulia> whatsit(1u\"kV\")\n\"voltage!\"\n\njulia> whatsit(1u\"A\" * 2.5u\"Ω\")\n\"voltage!\"","category":"page"},{"location":"highlights/#Dimensions-in-a-type-definition","page":"Highlighted features","title":"Dimensions in a type definition","text":"","category":"section"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"It may be tempting to specify the dimensions of a quantity in a type definition, e.g.","category":"page"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"struct Person\n    height::Unitful.Length\n    mass::Unitful.Mass\nend","category":"page"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"However, these are abstract types. If performance is important, it may be better just to pick a concrete Quantity type:","category":"page"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"struct Person\n    height::typeof(1.0u\"m\")\n    mass::typeof(1.0u\"kg\")\nend","category":"page"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"You can still create a Person as Person(5u\"ft\"+10u\"inch\", 75u\"kg\"); the unit conversion happens automatically.","category":"page"},{"location":"highlights/#Making-new-units-and-dimensions","page":"Highlighted features","title":"Making new units and dimensions","text":"","category":"section"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"You can make new units using the @unit macro on the fly:","category":"page"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"julia> @unit yd5 \"yd5\" FiveYards 5u\"yd\" false\nyd5","category":"page"},{"location":"highlights/#Arrays","page":"Highlighted features","title":"Arrays","text":"","category":"section"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"Promotion is used to create arrays of a concrete type where possible, such that arrays of unitful quantities are stored efficiently in memory. However, if necessary, arrays can hold quantities with different dimensions, even mixed with unitless numbers. Doing so will suffer a performance penalty compared with the fast performance attainable with an array of concrete type (e.g. as resulting from [1.0u\"m\", 2.0u\"cm\", 3.0u\"km\"]). However, it could be useful in toy calculations for general relativity where some conventions yield matrices with mixed dimensions:","category":"page"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"julia> using LinearAlgebra\n\njulia> Diagonal([-1.0u\"c^2\", 1.0, 1.0, 1.0]);","category":"page"},{"location":"highlights/#Logarithmic-units","page":"Highlighted features","title":"Logarithmic units","text":"","category":"section"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"julia> uconvert(u\"mW*s\", 20u\"dBm/Hz\")\n100.0 s mW","category":"page"},{"location":"highlights/#Units-with-rational-exponents","page":"Highlighted features","title":"Units with rational exponents","text":"","category":"section"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"julia> 1.0u\"V/sqrt(Hz)\"\n1.0 V Hz^-1/2","category":"page"},{"location":"highlights/#Exact-conversions-respected","page":"Highlighted features","title":"Exact conversions respected","text":"","category":"section"},{"location":"highlights/","page":"Highlighted features","title":"Highlighted features","text":"julia> uconvert(u\"ft\",1u\"inch\")\n1//12 ft","category":"page"},{"location":"manipulations/","page":"Manipulating units","title":"Manipulating units","text":"DocTestSetup = quote\n    using Unitful\nend","category":"page"},{"location":"manipulations/#Manipulating-units","page":"Manipulating units","title":"Manipulating units","text":"","category":"section"},{"location":"manipulations/#Unitful-string-macro","page":"Manipulating units","title":"Unitful string macro","text":"","category":"section"},{"location":"manipulations/","page":"Manipulating units","title":"Manipulating units","text":"Unitful.@u_str\nUnitful.register","category":"page"},{"location":"manipulations/#Unitful.@u_str","page":"Manipulating units","title":"Unitful.@u_str","text":"@u_str(unit)\n\nString macro to easily recall units, dimensions, or quantities defined in unit modules that have been registered with Unitful.register.\n\nIf the same symbol is used for a Unitful.Units object defined in different modules, then the symbol found in the most recently registered module will be used.\n\nNote that what goes inside must be parsable as a valid Julia expression. In other words, u\"N m\" will fail if you intended to write u\"N*m\".\n\nExamples:\n\njulia> 1.0u\"m/s\"\n1.0 m s^-1\n\njulia> 1.0u\"N*m\"\n1.0 m N\n\njulia> u\"m,kg,s\"\n(m, kg, s)\n\njulia> typeof(1.0u\"m/s\")\nQuantity{Float64, 𝐋 𝐓^-1, Unitful.FreeUnits{(m, s^-1), 𝐋 𝐓^-1, nothing}}\n\njulia> u\"ħ\"\n1.0545718176461565e-34 J s\n\n\n\n\n\n","category":"macro"},{"location":"manipulations/#Unitful.register","page":"Manipulating units","title":"Unitful.register","text":"register(unit_module::Module)\n\nMakes Unitful aware of units defined in a new unit module, including making the @u_str macro work with these units. By default, Unitful is itself a registered module. Note that Main is not, so if you define new units at the REPL, you will probably want to do Unitful.register(Main).\n\nExample:\n\n# somewhere in a custom units package...\nmodule MyUnitsPackage\nusing Unitful\n\nfunction __init__()\n    ...\n    Unitful.register(MyUnitsPackage)\nend\nend #module\n\n\n\n\n\n","category":"function"},{"location":"manipulations/#Dimension-and-unit-inspection","page":"Manipulating units","title":"Dimension and unit inspection","text":"","category":"section"},{"location":"manipulations/","page":"Manipulating units","title":"Manipulating units","text":"We define a function dimension that turns, for example, acre^2 or 1*acre^2 into 𝐋^4. We can usually add quantities with the same dimension, regardless of specific units (FixedUnits cannot be automatically converted, however). Note that dimensions cannot be determined by powers of the units: ft^2 is an area, but so is ac^1 (an acre).","category":"page"},{"location":"manipulations/","page":"Manipulating units","title":"Manipulating units","text":"There is also a function unit that turns, for example, 1*acre^2 into acre^2. You can then query whether the units are FreeUnits, FixedUnits, etc.","category":"page"},{"location":"manipulations/","page":"Manipulating units","title":"Manipulating units","text":"Unitful.unit\nUnitful.dimension","category":"page"},{"location":"manipulations/#Unitful.unit","page":"Manipulating units","title":"Unitful.unit","text":"unit(x::Quantity{T,D,U}) where {T,D,U}\nunit(x::Type{Quantity{T,D,U}}) where {T,D,U}\n\nReturns the units associated with a Quantity or Quantity type.\n\nExamples:\n\njulia> unit(1.0u\"m\") == u\"m\"\ntrue\n\njulia> unit(typeof(1.0u\"m\")) == u\"m\"\ntrue\n\n\n\n\n\nunit(x::Number)\n\nReturns a Unitful.FreeUnits{(), NoDims} object to indicate that ordinary numbers have no units. This is a singleton, which we export as NoUnits. The unit is displayed as an empty string.\n\nExamples:\n\njulia> typeof(unit(1.0))\nUnitful.FreeUnits{(), NoDims, nothing}\n\njulia> typeof(unit(Float64))\nUnitful.FreeUnits{(), NoDims, nothing}\n\njulia> unit(1.0) == NoUnits\ntrue\n\n\n\n\n\nunit(x::Dates.FixedPeriod)\nunit(x::Type{<:Dates.FixedPeriod})\n\nReturn the units that correspond to a particular period.\n\nExamples\n\njulia> unit(Second(15)) == u\"s\"\ntrue\n\njulia> unit(Hour) == u\"hr\"\ntrue\n\n\n\n\n\n","category":"function"},{"location":"manipulations/#Unitful.dimension","page":"Manipulating units","title":"Unitful.dimension","text":"dimension(x::Unit)\n\nReturns a Unitful.Dimensions object describing the given unit x.\n\n\n\n\n\ndimension(x::Number)\ndimension(x::Type{T}) where {T<:Number}\n\nReturns a Unitful.Dimensions{()} object to indicate that ordinary numbers are dimensionless. This is a singleton, which we export as NoDims. The dimension is displayed as an empty string.\n\nExamples:\n\njulia> typeof(dimension(1.0))\nUnitful.Dimensions{()}\n\njulia> typeof(dimension(Float64))\nUnitful.Dimensions{()}\n\njulia> dimension(1.0) == NoDims\ntrue\n\n\n\n\n\ndimension(u::Units{U,D}) where {U,D}\n\nReturns a Unitful.Dimensions object corresponding to the dimensions of the units, D. For a dimensionless combination of units, a Unitful.Dimensions{()} object is returned (NoDims).\n\nExamples:\n\njulia> dimension(u\"m\")\n𝐋\n\njulia> typeof(dimension(u\"m\"))\nUnitful.Dimensions{(Unitful.Dimension{:Length}(1//1),)}\n\njulia> dimension(u\"m/km\")\nNoDims\n\n\n\n\n\ndimension(x::Quantity{T,D}) where {T,D}\ndimension(::Type{Quantity{T,D,U}}) where {T,D,U}\n\nReturns a Unitful.Dimensions object D corresponding to the dimensions of quantity x. For a dimensionless Unitful.Quantity, a Unitful.Dimensions{()} object is returned (NoDims).\n\nExamples:\n\njulia> dimension(1.0u\"m\")\n𝐋\n\njulia> typeof(dimension(1.0u\"m/μm\"))\nUnitful.Dimensions{()}\n\n\n\n\n\n","category":"function"},{"location":"manipulations/#Unit-stripping","page":"Manipulating units","title":"Unit stripping","text":"","category":"section"},{"location":"manipulations/","page":"Manipulating units","title":"Manipulating units","text":"Unitful.ustrip","category":"page"},{"location":"manipulations/#Unitful.ustrip","page":"Manipulating units","title":"Unitful.ustrip","text":"ustrip(u::Units, x::Quantity)\nustrip(T::Type, u::Units, x::Quantity)\n\nConvert x to units u using uconvert and return the number out the front of the resulting quantity. If T is supplied, also convert the resulting number into type T.\n\nThis function is mainly intended for compatibility with packages that don't know how to handle quantities.\n\njulia> ustrip(u\"m\", 1u\"mm\") == 1//1000\ntrue\n\njulia> ustrip(Float64, u\"m\", 2u\"mm\") == 0.002\ntrue\n\n\n\n\n\nustrip(x::Number)\nustrip(x::Quantity)\n\nReturns the number out in front of any units. The value of x may differ from the number out front of the units in the case of dimensionless quantities, e.g. 1m/mm != 1. See uconvert and the example below. Because the units are removed, information may be lost and this should be used with some care — see ustrip(u,x) for a safer alternative.\n\njulia> ustrip(2u\"μm/m\") == 2\ntrue\n\njulia> uconvert(NoUnits, 2u\"μm/m\") == 2//1000000\ntrue\n\n\n\n\n\nustrip(x::Array{Q}) where {Q <: Quantity}\n\nStrip units from an Array by reinterpreting to type T. The resulting Array is a not a copy, but rather a unit-stripped view into array x. Because the units are removed, information may be lost and this should be used with some care.\n\nThis function is provided primarily for compatibility purposes; you could pass the result to PyPlot, for example.\n\njulia> a = [1u\"m\", 2u\"m\"]\n2-element Vector{Quantity{Int64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}:\n 1 m\n 2 m\n\njulia> b = ustrip(a)\n2-element reinterpret(Int64, ::Vector{Quantity{Int64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}):\n 1\n 2\n\njulia> a[1] = 3u\"m\"; b\n2-element reinterpret(Int64, ::Vector{Quantity{Int64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}):\n 3\n 2\n\n\n\n\n\nustrip(A::Diagonal)\nustrip(A::Bidiagonal)\nustrip(A::Tridiagonal)\nustrip(A::SymTridiagonal)\n\nStrip units from various kinds of matrices by calling ustrip on the underlying vectors.\n\n\n\n\n\n","category":"function"},{"location":"manipulations/#Unit-multiplication","page":"Manipulating units","title":"Unit multiplication","text":"","category":"section"},{"location":"manipulations/","page":"Manipulating units","title":"Manipulating units","text":"*(::Unitful.Units, ::Unitful.Units...)\n*(::Unitful.Dimensions, ::Unitful.Dimensions...)","category":"page"},{"location":"manipulations/#Base.:*-Tuple{Unitful.Units, Vararg{Unitful.Units}}","page":"Manipulating units","title":"Base.:*","text":"*(a0::Units, a::Units...)\n\nGiven however many units, multiply them together. This is actually handled by a few different methods, since we have FreeUnits, ContextUnits, and FixedUnits.\n\nCollect Unitful.Unit objects from the type parameter of the Unitful.Units objects. For identical units including SI prefixes (i.e. cm ≠ m), collect powers and sort uniquely by the name of the Unit. The unique sorting permits easy unit comparisons.\n\nExamples:\n\njulia> u\"kg*m/s^2\"\nkg m s^-2\n\njulia> u\"m/s*kg/s\"\nkg m s^-2\n\njulia> typeof(u\"m/s*kg/s\") == typeof(u\"kg*m/s^2\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"manipulations/#Base.:*-Tuple{Unitful.Dimensions, Vararg{Unitful.Dimensions}}","page":"Manipulating units","title":"Base.:*","text":"*(a0::Dimensions, a::Dimensions...)\n\nGiven however many dimensions, multiply them together.\n\nCollect Unitful.Dimension objects from the type parameter of the Unitful.Dimensions objects. For identical dimensions, collect powers and sort uniquely by the name of the Dimension.\n\nExamples:\n\njulia> u\"𝐌*𝐋/𝐓^2\"\n𝐋 𝐌 𝐓^-2\n\njulia> u\"𝐋*𝐌/𝐓^2\"\n𝐋 𝐌 𝐓^-2\n\njulia> typeof(u\"𝐋*𝐌/𝐓^2\") == typeof(u\"𝐌*𝐋/𝐓^2\")\ntrue\n\n\n\n\n\n","category":"method"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"DocTestSetup = quote\n    using Unitful\n    using Unitful:AffineError\nend","category":"page"},{"location":"temperature/#Temperature-scales","page":"Temperature scales","title":"Temperature scales","text":"","category":"section"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"Temperatures require some care. Temperature scales like K and Ra are thermodynamic temperature scales, with zero on the scale corresponding to absolute zero. Unit conversions between thermodynamic or absolute temperatures are done by multiplying conversion factors, as usual. Also in common use are temperature scales like °C or °F, which are defined relative to arbitrary offsets. For example, in the case of °C, zero on the scale is the freezing point of water, not absolute zero. To convert between relative temperature scales, an affine transformation is required. Absolute and relative temperatures can be distinguished by type to avoid ambiguities that could yield erroneous or unexpected results. On relative temperature scales, problems can arise because e.g. 0°C + 0°C could mean 0°C or 273.15°C, depending on whether the operands are variously interpreted as temperature differences or as absolute temperatures. On thermodynamic temperature scales, there is no ambiguity.","category":"page"},{"location":"temperature/#Temperatures-on-absolute-scales","page":"Temperature scales","title":"Temperatures on absolute scales","text":"","category":"section"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"Unit conversions between temperatures on absolute scales like Kelvin or Rankine are done in the usual way by multiplication of a scale factor. For example, we have:","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"julia> uconvert(u\"K\", 1u\"Ra\")\n5//9 K","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"We can identify absolute temperatures using the Unitful.AbsoluteScaleTemperature type alias:","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"julia> 1u\"K\" isa Unitful.AbsoluteScaleTemperature\ntrue","category":"page"},{"location":"temperature/#Temperatures-on-relative-scales","page":"Temperature scales","title":"Temperatures on relative scales","text":"","category":"section"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"Unit conversions between temperatures on relative scales like Celsius or Fahrenheit involve an affine transformation, that is, a scaling plus some translation (scale offset). In Unitful, relative scale temperatures are considered to have the same dimension as absolute scale temperatures, as expected. However, temperatures on relative and absolute scales are distinguished by the type of the Unitful.Units object (and therefore the type of the Unitful.Quantity object).","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"julia> uconvert(u\"°C\", 32u\"°F\")\n0//1 °C","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"We can identify relative scale temperatures using the Unitful.RelativeScaleTemperature type alias, e.g.:","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"julia> 1u\"°C\" isa Unitful.RelativeScaleTemperature\ntrue","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"Some operations are not well defined with relative scale temperatures, and therefore throw an Unitful.AffineError (please report any unexpected behavior on the GitHub issue tracker).","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"julia> 32u\"°F\" + 1u\"°F\"\nERROR: AffineError: an invalid operation was attempted with affine quantities: 32 °F + 1 °F\n[...]\n\njulia> 32u\"°F\" * 2\nERROR: AffineError: an invalid operation was attempted with affine quantities: 32 °F*2\n[...]","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"There is a general mechanism for making units that indicate quantities should unit-convert under some affine transformation. While the usual use case is for relative scale temperatures, nothing in the implementation limits it as such. Accordingly, relative scale temperatures are considered to be Unitful.AffineQuantity objects with dimensions of temperature. The units on \"affine quantities\" are Unitful.AffineUnits objects.","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"Making your own affine units typically requires two steps. First, define the absolute unit using the Unitful.@unit macro. Second, use the Unitful.@affineunit macro to make a corresponding affine unit. As an example, this is how Ra and °F are implemented:","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"@unit Ra \"Ra\" Rankine (5//9)*K false\n@affineunit °F \"°F\" (45967//100)Ra","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"The preferred unit for promoting temperatures is usually K when using Unitful.FreeUnits.","category":"page"},{"location":"temperature/","page":"Temperature scales","title":"Temperature scales","text":"Unitful.AffineUnits\nUnitful.AffineQuantity\nUnitful.ScalarUnits\nUnitful.ScalarQuantity\nUnitful.absoluteunit","category":"page"},{"location":"temperature/#Unitful.AffineUnits","page":"Temperature scales","title":"Unitful.AffineUnits","text":"AffineUnits{N,D,A} = Units{N,D,A} where A<:Affine\n\nUseful for dispatching on unit objects that indicate a quantity should affine-transform under unit conversion, like absolute temperatures. Not exported.\n\n\n\n\n\n","category":"type"},{"location":"temperature/#Unitful.AffineQuantity","page":"Temperature scales","title":"Unitful.AffineQuantity","text":"AffineQuantity{T,D,U} = AbstractQuantity{T,D,U} where U<:AffineUnits\n\nUseful for dispatching on quantities that affine-transform under unit conversion, like absolute temperatures. Not exported.\n\n\n\n\n\n","category":"type"},{"location":"temperature/#Unitful.ScalarUnits","page":"Temperature scales","title":"Unitful.ScalarUnits","text":"ScalarUnits{N,D} = Units{N,D,nothing}\n\nUseful for dispatching on unit objects that indicate a quantity should transform in the usual scalar way under unit conversion. Not exported.\n\n\n\n\n\n","category":"type"},{"location":"temperature/#Unitful.ScalarQuantity","page":"Temperature scales","title":"Unitful.ScalarQuantity","text":"ScalarQuantity{T,D,U} = AbstractQuantity{T,D,U} where U<:ScalarUnits\n\nUseful for dispatching on quantities that transform in the usual scalar way under unit conversion. Not exported.\n\n\n\n\n\n","category":"type"},{"location":"temperature/#Unitful.absoluteunit","page":"Temperature scales","title":"Unitful.absoluteunit","text":"absoluteunit(::Units)\nabsoluteunit(::Quantity)\n\nGiven a unit or quantity, which may or may not be affine (e.g. °C), return the corresponding unit on the absolute temperature scale (e.g. K). Passing a Unitful.ContextUnits object will return another ContextUnits object with the same promotion unit, which may be an affine unit, so take care.\n\n\n\n\n\n","category":"function"},{"location":"extending/#Extending-Unitful","page":"Extending Unitful","title":"Extending Unitful","text":"","category":"section"},{"location":"extending/#Making-your-own-units-package","page":"Extending Unitful","title":"Making your own units package","text":"","category":"section"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"New units or dimensions can be defined from the Julia REPL or from within other packages. To avoid duplication of code and effort, it is advised to put new unit definitions into a Julia package that is then published for others to use. For an example of how to do this, examine the code in UnitfulUS.jl, which defines U.S. customary units. It's actually very easy! Just make sure you read all of the cautionary notes on this page. If you make a units package for Unitful, please submit a pull request so that I can provide a link from Unitful's README!","category":"page"},{"location":"extending/#Some-limitations","page":"Extending Unitful","title":"Some limitations","text":"","category":"section"},{"location":"extending/#Precompilation","page":"Extending Unitful","title":"Precompilation","text":"","category":"section"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"When creating new units in a precompiled package that need to persist into run-time (usually true), it is important that the following make it into your code:","category":"page"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"function __init__()\n    Unitful.register(YourModule)\nend","category":"page"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"By calling Unitful.register in your __init__ function, you tell Unitful about some internal data required to make Unit conversions work and also make your units accessible to Unitful's @u_str macro. Your unit symbols should ideally be distinctive to avoid colliding with symbols defined in other packages or in Unitful. If there is a collision, the @u_str macro will still work, but it will use the unit found in whichever package was registered most recently, and it will emit a warning every time.","category":"page"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"If you use the @u_str macro with the units defined in your package, you'll also need to call Unitful.register() at the top level of your package at compile time.","category":"page"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"In the unlikely case that you've used @dimension, you will also need the following incantation:","category":"page"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"const localpromotion = copy(Unitful.promotion)\nfunction __init__()\n    Unitful.register(YourModule)\n    merge!(Unitful.promotion, localpromotion)\nend","category":"page"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"The definition of localpromotion must happen after all new units (dimensions) have been defined.","category":"page"},{"location":"extending/#Type-uniqueness","page":"Extending Unitful","title":"Type uniqueness","text":"","category":"section"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"Currently, when the @dimension, @derived_dimension, @refunit, or @unit macros are used, some unique symbols must be provided which are used to differentiate types in dispatch. These are typically the names of dimensions or units (e.g. Length, Meter, etc.) One problem that could occur is that if multiple units or dimensions are defined with the same name, then they will be indistinguishable in dispatch and errors will result.","category":"page"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"I don't expect a flood of units packages to come out, so probably the likelihood of name collision is pretty small. When defining units yourself, do take care to use unique symbols, perhaps with the aid of Base.gensym() if creating units at runtime. When making packages, look and see what symbols are used by existing units packages to avoid trouble.","category":"page"},{"location":"extending/#Archaic-or-fictitious-unit-systems","page":"Extending Unitful","title":"Archaic or fictitious unit systems","text":"","category":"section"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"In the rare event that you want to define physical units which are not convertible to SI units, you need to do a bit of extra work. To be clear, such a conversion should always exist, in principle. One can imagine, however, archaic or fictitious unit systems for which a precise conversion to SI units is unknown. For example, a cullishigay is one-third of a mudi, but only approximately 1.25 imperial bushels. There may be cases where you don't even have an approximate conversion to imperial bushels. At such a time, you may feel uncomfortable specifying the \"base unit\" of this hypothetical unit system in terms of an SI quantity, and may want to explicitly forbid any attempt to convert to SI units.","category":"page"},{"location":"extending/","page":"Extending Unitful","title":"Extending Unitful","text":"One can achieve this by defining new dimensions with the @dimension or @derived_dimension macros. The trick is to define dimensions that display suggestively like physical dimensions, like 𝐋*, 𝐓* etc., but are distinct as far as Julia's type system is concerned. Then, you can use @refunit to base units for these new dimensions without reference to SI. The result will be that attempted conversion between the hypothetical unit system and SI will fail with a DimensionError, so be sure you provide some hints in how your new dimensions are displayed to avoid confusing users. It would be confusing to throw a DimensionError when attempting to convert between lengths which are incompatible in the sense of the previous paragraph, when both lengths display their dimension as 𝐋.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"DocTestSetup = quote\n    using Unitful\nend","category":"page"},{"location":"conversion/#Conversion/promotion","page":"Conversion/promotion","title":"Conversion/promotion","text":"","category":"section"},{"location":"conversion/#Converting-between-units","page":"Conversion/promotion","title":"Converting between units","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Since convert in Julia already means something specific (conversion between Julia types), we define uconvert for conversion between units. Typically this will also involve a conversion between types, but this function takes care of figuring out which type is appropriate for representing the desired units.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Exact conversions between units are respected where possible. If rational arithmetic would result in an overflow, then floating-point conversion should proceed. Use of floating-point numbers inhibits exact conversion.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"uconvert","category":"page"},{"location":"conversion/#Unitful.uconvert","page":"Conversion/promotion","title":"Unitful.uconvert","text":"uconvert(a::Units, x::Quantity{T,D,U}) where {T,D,U}\n\nConvert a Unitful.Quantity to different units. The conversion will fail if the target units a have a different dimension than the dimension of the quantity x. You can use this method to switch between equivalent representations of the same unit, like N m and J.\n\nExample:\n\njulia> uconvert(u\"hr\",3602u\"s\")\n1801//1800 hr\n\njulia> uconvert(u\"J\",1.0u\"N*m\")\n1.0 J\n\n\n\n\n\n","category":"function"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Since objects are callable, we can also make Unitful.Units callable with a Number as an argument, for a unit conversion shorthand:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> u\"cm\"(1u\"m\")\n100 cm","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"This syntax is a little confusing, but becomes appealing with the function chaining operator |>:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> 1u\"m\" |> u\"cm\"\n100 cm","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Note that since Unitful.Units objects have no fields, we don't have to worry about ambiguity with constructor calls. This way of converting units results in behavior identical to calling uconvert.","category":"page"},{"location":"conversion/#Dimensionless-quantities","page":"Conversion/promotion","title":"Dimensionless quantities","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"For dimensionless quantities, uconvert can be used to strip the units without losing power-of-ten information:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> uconvert(Unitful.NoUnits, 1.0u\"μm/m\")\n1.0e-6\n\njulia> uconvert(Unitful.NoUnits, 1.0u\"m\")\nERROR: DimensionError:  and m are not dimensionally compatible.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"You can also directly convert to a subtype of Real or Complex:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> convert(Float64, 1.0u\"μm/m\")\n1.0e-6","category":"page"},{"location":"conversion/#Basic-promotion-mechanisms","page":"Conversion/promotion","title":"Basic promotion mechanisms","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"We decide the result units for addition and subtraction operations based on looking at the types only. We can't take runtime values into account without compromising runtime performance.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"If two quantities with the same units are added or subtracted, then the result units will be the same. If two quantities with differing units (but same dimension) are added or subtracted, then the result units will be specified by promotion.","category":"page"},{"location":"conversion/#Promotion-rules-for-specific-dimensions","page":"Conversion/promotion","title":"Promotion rules for specific dimensions","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"You can specify the result units for promoting quantities of a specific dimension once at the start of a Julia session. For example, you can specify that when promoting two quantities with different energy units, the resulting quantities should be in g*cm^2/s^2. This is accomplished by defining a Unitful.promote_unit method for the units themselves. Here's an example.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> using Unitful\n\njulia> Unitful.promote_unit(::S, ::T) where {S<:Unitful.EnergyUnits, T<:Unitful.EnergyUnits} = u\"g*cm^2/s^2\"\n\njulia> promote(2.0u\"J\", 1.0u\"kg*m^2/s^2\")\n(2.0e7 g cm^2 s^-2, 1.0e7 g cm^2 s^-2)\n\njulia> Unitful.promote_unit(::S, ::T) where {S<:Unitful.EnergyUnits, T<:Unitful.EnergyUnits} = u\"J\"\n\njulia> promote(2.0u\"J\", 1.0u\"kg*m^2/s^2\")\n(2.0 J, 1.0 J)","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"If you're wondering where Unitful.EnergyUnits comes from, it is defined in src/pkgdefaults.jl by the @derived_dimension macro. Similarly, the calls to the @dimension macro define Unitful.LengthUnits, Unitful.MassUnits, etc. None of these are exported.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Existing users of Unitful may want to call Unitful.promote_to_derived after Unitful loads to give similar behavior to Unitful 0.0.4 and below. It is not called by default.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Unitful.promote_to_derived","category":"page"},{"location":"conversion/#Unitful.promote_to_derived","page":"Conversion/promotion","title":"Unitful.promote_to_derived","text":"Unitful.promote_to_derived()\n\nDefines promotion rules to use derived SI units in promotion for common dimensions of quantities:\n\nJ (joule) for energy\nN (newton) for force\nW (watt) for power\nPa (pascal) for pressure\nC (coulomb) for charge\nV (volt) for voltage\nΩ (ohm) for resistance\nF (farad) for capacitance\nH (henry) for inductance\nWb (weber) for magnetic flux\nT (tesla) for B-field\nJ*s (joule-second) for action\n\nIf you want this as default behavior (it was for versions of Unitful prior to 0.1.0), consider invoking this function in your startup.jl file which is loaded when you open Julia. This function is not exported.\n\n\n\n\n\n","category":"function"},{"location":"conversion/#Fallback-promotion-rules","page":"Conversion/promotion","title":"Fallback promotion rules","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"The Unitful.preferunits function is used to designate fallback preferred units for each pure dimension for promotion. Such a fallback is required because you need some generic logic to take over when manipulating quantities with arbitrary dimensions.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"The default behavior is to promote to a combination of the base SI units, i.e. a quantity of dimension 𝐌*𝐋^2/(𝐓^2*𝚯) would be converted to kg*m^2/(s^2*K):","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> promote(1.0u\"J/K\", 1.0u\"g*cm^2/s^2/K\")\n(1.0 kg m^2 K^-1 s^-2, 1.0e-7 kg m^2 K^-1 s^-2)","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"You can however override this behavior by calling Unitful.preferunits at the start of a Julia session, specifically before Unitful.upreferred has been called or quantities have been promoted.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Unitful.preferunits\nUnitful.upreferred","category":"page"},{"location":"conversion/#Unitful.preferunits","page":"Conversion/promotion","title":"Unitful.preferunits","text":"preferunits(u0::Units, u::Units...)\n\nThis function specifies the default fallback units for promotion. Units provided to this function must have a pure dimension of power 1, like 𝐋 or 𝐓 but not 𝐋/𝐓 or 𝐋^2. The function will complain if this is not the case. Additionally, the function will complain if you provide two units with the same dimension, as a courtesy to the user. Finally, you cannot use affine units such as °C with this function.\n\nOnce Unitful.upreferred has been called or quantities have been promoted, this function will appear to have no effect.\n\nUsage example: preferunits(u\"m,s,A,K,cd,kg,mol\"...)\n\n\n\n\n\n","category":"function"},{"location":"conversion/#Unitful.upreferred","page":"Conversion/promotion","title":"Unitful.upreferred","text":"upreferred(x::Number)\nupreferred(x::Quantity)\n\nUnit-convert x to units which are preferred for the dimensions of x. If you are using the factory defaults, this function will unit-convert to a product of powers of base SI units. If quantity x has Unitful.ContextUnits(y,z), the resulting quantity will have units ContextUnits(z,z).\n\n\n\n\n\nupreferred(x::Units)\n\nReturn units which are preferred for the dimensions of x, which may or may not be equal to x, as specified by the preferunits function. If you are using the factory defaults, this function will return a product of powers of base SI units.\n\n\n\n\n\nupreferred(x::Dimensions)\n\nReturn units which are preferred for dimensions x. If you are using the factory defaults, this function will return a product of powers of base SI units (as Unitful.FreeUnits).\n\n\n\n\n\n","category":"function"},{"location":"conversion/#Array-promotion","page":"Conversion/promotion","title":"Array promotion","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Arrays are typed with as much specificity as possible upon creation. consider the following three cases:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> [1.0u\"m\", 2.0u\"m\"]\n2-element Vector{Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}:\n 1.0 m\n 2.0 m\n\njulia> [1.0u\"m\", 2.0u\"cm\"]\n2-element Vector{Quantity{Float64, 𝐋, Unitful.FreeUnits{(m,), 𝐋, nothing}}}:\n  1.0 m\n 0.02 m\n\njulia> [1.0u\"m\", 2.0]\n2-element Vector{Quantity{Float64}}:\n 1.0 m\n   2.0","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"In the first case, an array with a concrete type is created. Good performance should be attainable. The second case invokes promotion so that an array of concrete type can be created. The third case falls back to an abstract type, which cannot be stored efficiently and will incur a performance penalty. An additional benefit of having a concrete type is that we can dispatch on the dimensions of the array's elements:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> f(x::AbstractArray{T}) where {T<:Unitful.Length} = sum(x)\nf (generic function with 1 method)\n\njulia> f([1.0u\"m\", 2.0u\"cm\"])\n1.02 m\n\njulia> f([1.0u\"g\", 2.0u\"cm\"])\nERROR: MethodError: no method matching f(::Vector{Quantity{Float64}})\n[...]","category":"page"},{"location":"conversion/#Advanced-promotion-mechanisms","page":"Conversion/promotion","title":"Advanced promotion mechanisms","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"There are some new types as of Unitful.jl v0.2.0 that enable some fairly sophisticated promotion logic. Three concrete subtypes of Unitful.Units{N,D,A} are defined: Unitful.FreeUnits{N,D,A}, Unitful.ContextUnits{N,D,P,A}, and Unitful.FixedUnits{N,D,A}.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Units defined in the Unitful.jl package itself are all Unitful.FreeUnits{N,D,A} objects. The \"free\" in FreeUnits indicates that the object carries no information on its own about how it should respond during promotion. Other code in Unitful dictates that by default, quantities should promote to SI units. FreeUnits use the promotion mechanisms described in the above section, Basic promotion mechanisms. They used to be called Units in prior versions of Unitful.","category":"page"},{"location":"conversion/#ContextUnits","page":"Conversion/promotion","title":"ContextUnits","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Sometimes, a package may want to default to a particular behavior for promotion, in the presence of other packages that may require differing default behaviors. An example would be a CAD package for nanoscale device design: it makes more sense to promote to nanometers or microns than to meters. For this purpose we define Unitful.ContextUnits{N,D,P,A}. The P in this type signature should be some type Unitful.FreeUnits{M,D,B} (the dimensions must be the same). We refer to this as the \"context.\" ContextUnits may be easily instantiated by e.g. ContextUnits(nm, μm) for a nm unit that will promote to μm. Here's an example:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> μm = Unitful.ContextUnits(u\"μm\", u\"μm\")\nμm\n\njulia> nm = Unitful.ContextUnits(u\"nm\", u\"μm\")\nnm\n\njulia> 1.0μm + 1.0nm\n1.001 μm","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"If the context does not agree, then we fall back to FreeUnits:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> μm = Unitful.ContextUnits(u\"μm\", u\"μm\")\nμm\n\njulia> nm = Unitful.ContextUnits(u\"nm\", u\"cm\")\nnm\n\njulia> 1.0μm + 1.0nm\n1.001e-6 m","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Multiplying a ContextUnits by a FreeUnits yields a ContextUnits object, with the preferred units for the additional dimensions being determined by calling Unitful.upreferred on the FreeUnits object:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> mm = Unitful.ContextUnits(u\"mm\", u\"μm\")\nmm\n\njulia> isa(u\"g\", Unitful.FreeUnits)\ntrue\n\njulia> upreferred(u\"g\")\nkg\n\njulia> mm*u\"g\"\ng mm\n\njulia> isa(mm*u\"g\", Unitful.ContextUnits)\ntrue\n\njulia> upreferred(mm*u\"g\")\nkg μm","category":"page"},{"location":"conversion/#FixedUnits","page":"Conversion/promotion","title":"FixedUnits","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Sometimes, there may be times where it is required to disable automatic conversion between quantities with different units. For this purpose there are Unitful.FixedUnits{N,D,A}. Trying to add or compare two quantities with FixedUnits will throw an error, provided the units are not the same. Note that you can still add/compare a quantity with FixedUnits to a quantity with another kind of units; in that case, the result units (if applicable) are determined by the FixedUnits, overriding the preferred units from ContextUnits or FreeUnits. Multiplying FixedUnits with any other kind of units returns FixedUnits:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> mm_fix = Unitful.FixedUnits(u\"mm\")\nmm\n\njulia> cm_fix = Unitful.FixedUnits(u\"cm\")\ncm\n\njulia> 1mm_fix+2mm_fix\n3 mm\n\njulia> 1mm_fix+2u\"cm\"  # u\"cm\" is a FreeUnits object.\n21 mm\n\njulia> 1mm_fix+2*Unitful.ContextUnits(u\"cm\", u\"cm\")\n21 mm\n\njulia> isa(mm_fix*u\"cm\", Unitful.FixedUnits)\ntrue\n\njulia> 1mm_fix+2cm_fix\nERROR: automatic conversion prohibited.\n[...]\n\njulia> 1mm_fix == 1mm_fix\ntrue\n\njulia> 1mm_fix == 0.1u\"cm\"\ntrue\n\njulia> 1mm_fix == 0.1cm_fix\nERROR: automatic conversion prohibited.\n[...]","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"Much of this functionality is enabled by promote_unit definitions. These are not readily extensible by the user at this point.","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"    Unitful.promote_unit","category":"page"},{"location":"conversion/#Unitful.promote_unit","page":"Conversion/promotion","title":"Unitful.promote_unit","text":"promote_unit(::Units, ::Units...)\n\nGiven Units objects as arguments, this function returns a Units object appropriate for the result of promoting quantities which have these units. This function is kind of like promote_rule, except that it doesn't take types. It also does not return a tuple, but rather just a Unitful.Units object (or it throws an error).\n\nAlthough we had used promote_rule for Units objects in prior versions of Unitful, this was always kind of a hack; it doesn't make sense to promote units directly for a variety of reasons.\n\n\n\n\n\n","category":"function"},{"location":"conversion/#Unit-cancellation","page":"Conversion/promotion","title":"Unit cancellation","text":"","category":"section"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"For multiplication and division, note that powers-of-ten prefixes are significant in unit cancellation. For instance, mV/V is not simplified, although V/V is. Also, N*m/J is not simplified: there is currently no logic to decide whether or not units on a dimensionless quantity seem \"intentional\" or not. It is however possible to cancel units manually, by passing the dimensionless quantity to the NoUnits constructor. This takes into account different SI-prefixes:","category":"page"},{"location":"conversion/","page":"Conversion/promotion","title":"Conversion/promotion","text":"julia> using Unitful\n\njulia> 1u\"kN*m\"/4u\"J\" |> NoUnits\n250.0","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"DocTestSetup = quote\n    using Unitful\nend","category":"page"},{"location":"dates/#Interoperability-with-the-Dates-standard-library","page":"Interoperability with Dates","title":"Interoperability with the Dates standard library","text":"","category":"section"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"Julia's Dates standard library provides data types for representing specific points in time Date/DateTime and differences between them, i.e., periods. Unitful provides methods for using period types from the Dates standard library together with Quantitys.","category":"page"},{"location":"dates/#Support-for-Dates.FixedPeriods","page":"Interoperability with Dates","title":"Support for Dates.FixedPeriods","text":"","category":"section"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"The Dates.FixedPeriod union type includes all Dates.Periods that represent a fixed period of time, i.e., Dates.Week, Dates.Day, Dates.Hour, Dates.Minute, Dates.Second, Dates.Millisecond, Dates.Microsecond, and Dates.Nanosecond. These types can be converted to Quantitys or used in place of them.","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"note: Note\nDates.Year does not represent a fixed period and cannot be converted to a Quantity. While Unitful's yr unit is exactly equal to 365.25 days, a Dates.Year may contain 365 or 366 days.","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"Each FixedPeriod is considered equivalent to a Quantity. For example, Dates.Millisecond(5) corresponds to the quantity Int64(5)*u\"ms\". A FixedPeriod can be converted to the equivalent Quantity with a constructor:","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"Unitful.Quantity(::Dates.FixedPeriod)","category":"page"},{"location":"dates/#Unitful.Quantity-Tuple{Union{Day, Hour, Microsecond, Millisecond, Minute, Nanosecond, Second, Week}}","page":"Interoperability with Dates","title":"Unitful.Quantity","text":"Quantity(period::Dates.FixedPeriod)\n\nCreate a Quantity that corresponds to the given period. The numerical value of the resulting Quantity is of type Int64.\n\nExample\n\njulia> using Dates: Second\n\njulia> Quantity(Second(5))\n5 s\n\n\n\n\n\n","category":"method"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"In most respects, FixedPeriods behave like their equivalent quantities. They can be converted to other units using uconvert, used in arithmetic operations with other quantities, and they have a unit and dimension:","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"julia> using Dates: Hour\n\njulia> p = Hour(3)\n3 hours\n\njulia> uconvert(u\"s\", p)\n10800 s\n\njulia> p == 180u\"minute\"\ntrue\n\njulia> p < 1u\"d\"\ntrue\n\njulia> 5u\"s\" + p\n10805 s\n\njulia> 210u\"km\" / p\n70.0 km hr^-1\n\njulia> unit(p) === u\"hr\"\ntrue\n\njulia> dimension(p)\n𝐓","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"Conversely, a FixedPeriod can be created from a quantity using the appropriate constructor, convert, or round methods. This will fail (i.e., throw an InexactError) if the resulting value cannot be represented as an Int64:","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"julia> using Dates: Day, Hour, Millisecond\n\njulia> Millisecond(1.5u\"s\")\n1500 milliseconds\n\njulia> convert(Hour, 1u\"yr\")\n8766 hours\n\njulia> Day(1u\"yr\")\nERROR: InexactError: Int64(1461//4)\n[...]\n\njulia> round(Day, 1u\"yr\")\n365 days","category":"page"},{"location":"dates/#Support-for-Dates.CompoundPeriods","page":"Interoperability with Dates","title":"Support for Dates.CompoundPeriods","text":"","category":"section"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"The Dates standard library provides the Dates.CompoundPeriod type to represent sums of periods of different types:","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"using Dates: Day, Second\nDay(5) + Second(1)\ntypeof(ans)","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"Unitful provides facilities to work with CompoundPeriods as long as they consist only of FixedPeriods. Such CompoundPeriods can be converted to Quantitys using convert, uconvert, or round:","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"julia> using Dates: Day, Second\n\njulia> p = Day(5) + Second(1)\n5 days, 1 second\n\njulia> uconvert(u\"s\", p)\n432001//1 s\n\njulia> convert(typeof(1.0u\"yr\"), p)\n0.01368928562374832 yr\n\njulia> round(u\"d\", p)\n5//1 d\n\njulia> q = Month(1) + Day(1)  # Month is not a fixed period\n1 month, 1 day\n\njulia> uconvert(u\"s\", q)\nERROR: MethodError: no method matching Quantity{Rational{Int64},𝐓,Unitful.FreeUnits{(s,),𝐓,nothing}}(::Month)\n[...]","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"However, not all operations that are defined for FixedPeriods support CompoundPeriods as well. The reason for that is that a CompoundPeriod does not correspond to a specific unit:","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"julia> p = Day(365) + Hour(6)\n365 days, 6 hours\n\njulia> unit(p)  # A CompoundPeriod does not have a corresponding unit ...\nERROR: MethodError: no method matching unit(::Dates.CompoundPeriod)\n[...]\n\njulia> dimension(p)  # ... but it does have a dimension\n𝐓\n\njulia> Quantity(p)  # As a result, there is no Quantity type associated with it ...\nERROR: MethodError: no method matching Quantity(::Int64)\n[...]\n\njulia> T = typeof(1.0u\"hr\"); T(p)  # ... but it can be converted to a concrete time quantity\n8766.0 hr","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"Consequently, any operation whose result would depend on the input unit is not supported by CompoundPeriods. For example:","category":"page"},{"location":"dates/","page":"Interoperability with Dates","title":"Interoperability with Dates","text":"+(::Quantity, ::CompoundPeriod) and +(::CompoundPeriod, ::Quantity) error, since the unit of the result depends on the units of both arguments.\ndiv(::Quantity, ::CompoundPeriod) and div(::CompoundPeriod, ::Quantity) work, since the result is a dimensionless number.\nmod(::CompoundPeriod, ::Quantity) works, but mod(::Quantity, ::CompoundPeriod) does not, since the second argument determines the unit of the returned quantity.","category":"page"},{"location":"LICENSE/#License","page":"License","title":"License","text":"","category":"section"},{"location":"LICENSE/","page":"License","title":"License","text":"using Markdown\nopen(Markdown.parse, \"LICENSE.md\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using Unitful\nend","category":"page"},{"location":"#Unitful.jl","page":"Home","title":"Unitful.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for physical units. Available here. Inspired by:","category":"page"},{"location":"","page":"Home","title":"Home","text":"SIUnits.jl\nEngUnits.jl\nUnits.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"We want to support not only SI units but also any other unit system. We also want to minimize or in some cases eliminate the run-time penalty of units. There should be facilities for dimensional analysis. All of this should integrate easily with the usual mathematical operations and collections that are defined in Julia.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package requires Julia 1.0. Older versions will not be supported.\n] add Unitful\nusing Unitful","category":"page"},{"location":"","page":"Home","title":"Home","text":"Unitful aims for generality, but has some useful functionality out of the box.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Base dimensions like length, mass, time, etc. are defined.\nDerived dimensions like volume, energy, momentum, etc. are defined.\nBase and derived SI units with their power-of-ten prefixes are defined.\nSome other common units are defined, without power-of-ten prefixes.\nSensible default promotion behavior is specified.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Take a look at src/pkgdefaults.jl for a complete list. Note that some unit abbreviations conflict with other definitions or syntax:","category":"page"},{"location":"","page":"Home","title":"Home","text":"inch is used instead of in, since in conflicts with Julia syntax\nminute is used instead of min, since min is a commonly used function\nhr is used instead of h, since h is revered as the Planck constant\nhbar is hectobars in the SI system, so ħ is used for the reduced Plank constant","category":"page"},{"location":"#Important-note-on-namespaces","page":"Home","title":"Important note on namespaces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Units, dimensions, and fundamental constants are not exported from Unitful. This is to avoid proliferating symbols in your namespace unnecessarily. You can retrieve them from Unitful in one of three ways:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use the @u_str string macro.\nExplicitly import from the Unitful package to bring specific symbols into the calling namespace.\nusing Unitful.DefaultSymbols will bring the following symbols into the calling namespace:\nDimensions 𝐋,𝐌,𝐓,𝐈,𝚯,𝐉,𝐍 for length, mass, time, current, temperature, luminosity, and amount, respectively.\nBase and derived SI units, with SI prefixes (except for cd, which conflicts with Base.cd)\n° (degrees)","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have been using the SIUnits.jl   package, this is not unlike typing using SIUnits.ShortUnits with that package.","category":"page"},{"location":"#Usage-examples","page":"Home","title":"Usage examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using Unitful\n    °C = Unitful.°C\n    °F = Unitful.°F\n    Ra = Unitful.Ra\n    K = Unitful.K\n    μm = Unitful.μm\n    m = Unitful.m\n    hr = Unitful.hr\n    minute = Unitful.minute\n    s = Unitful.s\n    F = Unitful.F\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> 1u\"kg\" == 1000u\"g\"             # Equivalence implies unit conversion\ntrue\n\njulia> !(1u\"kg\" === 1000u\"g\")         # ...and yet we can distinguish these...\ntrue\n\njulia> 1u\"kg\" === 1u\"kg\"              # ...and these are indistinguishable.\ntrue","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the next examples we assume we have brought some units into our namespace, e.g. const m = u\"m\", etc.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> uconvert(°C, 212°F)\n100//1 °C\n\njulia> uconvert(μm/(m*Ra), 9μm/(m*K))\n5//1 μm m^-1 Ra^-1\n\njulia> mod(1hr+3minute+5s, 24s)\n17 s","category":"page"},{"location":"","page":"Home","title":"Home","text":"One useful interactive function is being able to convert to preferred (in this case SI) units. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> upreferred(F/m)\nA^2 s^4 kg^-1 m^-3","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nQuantities in °C or ⁠°F always unit-convert under an affine transformation that takes their relative scales into account. To avoid ambiguities that can lead to incorrect results, the units °C and °F cannot be used in Unitful to represent temperature differences. Fortunately, 1°C - 0°C == 1K and 1°F - 0°F == 1Ra, so the absolute temperature scales Kelvin (K) and Rankine (Ra) can be used easily to represent temperature differences.","category":"page"},{"location":"","page":"Home","title":"Home","text":"See test/runtests.jl for more usage examples.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"DocTestSetup = quote\n    using Unitful\nend","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/#Overview","page":"Types","title":"Overview","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"We define a Unitful.Unit{U,D} type to represent a unit (U is a symbol, like :Meter, and D keeps track of dimensional information). Fields of a Unit object keep track of a rational exponents and a power-of-ten prefix. We don't allow arbitrary floating point exponents of units because they probably aren't very useful. The prefixes on units (e.g. nm or km) may help to avoid overflow issues and general ugliness.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Usually, the user interacts only with Units objects, not Unit objects. This is because generically, more than one unit is needed to describe a quantity. An abstract type Unitful.Units{N,D,A} is defined, where N is always a tuple of Unit objects, D is a Unitful.Dimensions{N} object such as 𝐋, the object representing the length dimension, and A is a translation for affine quantities.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Subtypes of Unitful.Units{N,D,A} are used to implement different behaviors for how to promote dimensioned quantities. The concrete subtypes have no fields and are therefore immutable singletons. Currently implemented subtypes of Unitful.Units{N,D,A} include Unitful.FreeUnits{N,D,A}, Unitful.ContextUnits{N,D,P,A}, and Unitful.FixedUnits{N,D,A}. Units defined in the Unitful.jl package itself are all Unitful.FreeUnits{N,D,A} objects.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Finally, we define physical quantity types as Quantity{T<:Number, D, U}, where D :: Dimensions and U <: Units. By putting units in the type signature of a quantity, staged functions can be used to offload as much of the unit computation to compile-time as is possible. By also having the dimensions explicitly in the type signature, dispatch can be done on dimensions: isa(1u\"m\", Unitful.Length) == true. This works because Length is a type alias for some subset of Unitful.Quantity subtypes.","category":"page"},{"location":"types/#API","page":"Types","title":"API","text":"","category":"section"},{"location":"types/#Quantities","page":"Types","title":"Quantities","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"    Unitful.AbstractQuantity\n    Unitful.Quantity\n    Unitful.DimensionlessQuantity","category":"page"},{"location":"types/#Unitful.AbstractQuantity","page":"Types","title":"Unitful.AbstractQuantity","text":"abstract type AbstractQuantity{T,D,U} <: Number end\n\nRepresents a generic quantity type, whose dimensions and units are specified in the type signature.  The dimensions and units are allowed to be the empty set, in which case a dimensionless, unitless number results.\n\nThe type parameter T represents the numeric backing type. The type parameters D :: Unitful.Dimensions and U <: Unitful.Units. Of course, the dimensions follow from the units, but the type parameters are kept separate to permit convenient dispatch on dimensions.\n\n\n\n\n\n","category":"type"},{"location":"types/#Unitful.Quantity","page":"Types","title":"Unitful.Quantity","text":"struct Quantity{T,D,U} <: AbstractQuantity{T,D,U}\n\nA concrete subtype of Unitful.AbstractQuantity.\n\nThe type parameter T represents the numeric backing type. The type parameters D :: Unitful.Dimensions and U <: Unitful.Units.\n\n\n\n\n\n","category":"type"},{"location":"types/#Unitful.DimensionlessQuantity","page":"Types","title":"Unitful.DimensionlessQuantity","text":"DimensionlessQuantity{T,U} = AbstractQuantity{T, NoDims, U}\n\nUseful for dispatching on Unitful.Quantity types that may have units but no dimensions. (Units with differing power-of-ten prefixes are not canceled out.)\n\nExample:\n\njulia> isa(1.0u\"mV/V\", DimensionlessQuantity)\ntrue\n\n\n\n\n\n","category":"type"},{"location":"types/#Units-and-dimensions","page":"Types","title":"Units and dimensions","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"    Unitful.Unitlike\n    Unitful.Units\n    Unitful.FreeUnits\n    Unitful.ContextUnits\n    Unitful.FixedUnits\n    Unitful.Dimensions\n    Unitful.Unit\n    Unitful.Dimension","category":"page"},{"location":"types/#Unitful.Unitlike","page":"Types","title":"Unitful.Unitlike","text":"abstract type Unitlike end\n\nRepresents units or dimensions. Dimensions are unit-like in the sense that they are not numbers but you can multiply or divide them and exponentiate by rationals.\n\n\n\n\n\n","category":"type"},{"location":"types/#Unitful.Units","page":"Types","title":"Unitful.Units","text":"abstract type Units{N,D,A} <: Unitlike end\n\nAbstract supertype of all units objects, which can differ in their implementation details. A is a translation for affine quantities; for non-affine quantities it is nothing.\n\n\n\n\n\n","category":"type"},{"location":"types/#Unitful.FreeUnits","page":"Types","title":"Unitful.FreeUnits","text":"struct FreeUnits{N,D,A} <: Units{N,D,A}\n\nInstances of this object represent units, possibly combinations thereof. These behave like units have behaved in previous versions of Unitful, and provide a basic level of functionality that should be acceptable to most users. See Basic promotion mechanisms in the docs for details.\n\nExample: the unit m is actually a singleton of type Unitful.FreeUnits{(Unitful.Unit{:Meter, 𝐋}(0, 1//1),), 𝐋, nothing}. After dividing by s, a singleton of type Unitful.FreeUnits{(Unitful.Unit{:Meter, 𝐋}(0, 1//1), Unitful.Unit{:Second, 𝐓}(0, -1//1)), 𝐋/𝐓, nothing} is returned.\n\n\n\n\n\n","category":"type"},{"location":"types/#Unitful.ContextUnits","page":"Types","title":"Unitful.ContextUnits","text":"struct ContextUnits{N,D,P,A} <: Units{N,D,A}\n\nInstances of this object represent units, possibly combinations thereof. It is in most respects like FreeUnits{N,D,A}, except that the type parameter P is again a FreeUnits{M,D} type that specifies a preferred unit for promotion. See Advanced promotion mechanisms in the docs for details.\n\n\n\n\n\n","category":"type"},{"location":"types/#Unitful.FixedUnits","page":"Types","title":"Unitful.FixedUnits","text":"struct FixedUnits{N,D,A} <: Units{N,D,A} end\n\nInstances of this object represent units, possibly combinations thereof. These are primarily intended for use when you would like to disable automatic unit conversions. See Advanced promotion mechanisms in the docs for details.\n\n\n\n\n\n","category":"type"},{"location":"types/#Unitful.Dimensions","page":"Types","title":"Unitful.Dimensions","text":"struct Dimensions{N} <: Unitlike\n\nInstances of this object represent dimensions, possibly combinations thereof.\n\n\n\n\n\n","category":"type"},{"location":"types/#Unitful.Unit","page":"Types","title":"Unitful.Unit","text":"struct Unit{U,D}\n    tens::Int\n    power::Rational{Int}\nend\n\nDescription of a physical unit, including powers-of-ten prefixes and powers of the unit. The name of the unit is encoded in the type parameter U as a symbol, e.g. :Meter, :Second, :Gram, etc. The type parameter D is a Dimensions{N} object, for instance Unit{:Meter, 𝐋} or Unit{:Liter, 𝐋^3}. Note that the dimension information refers to the unit, not powers of the unit.\n\nUnit{U,D} objects are almost never explicitly manipulated by the user. They are collected in a tuple, which is used for the type parameter N of a Units{N,D,A} object.\n\n\n\n\n\n","category":"type"},{"location":"types/#Unitful.Dimension","page":"Types","title":"Unitful.Dimension","text":"struct Dimension{D}\n    power::Rational{Int}\nend\n\nDescription of a dimension. The name of the dimension D is a symbol, e.g. :Length, :Time, :Mass, etc.\n\nDimension{D} objects are collected in a tuple, which is used for the type parameter N of a Dimensions{N} object.\n\n\n\n\n\n","category":"type"}]
}
